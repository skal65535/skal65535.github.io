<!-- skal/ (pascal.massimino@gmail.com) 2023 -->
<!DOCTYPE html>
<html>

<head>
<title>Stippling experiment</title>

<style>
#drop-area {
  border: 3px dashed #ccc;
  border-radius: 20px;
  font-family: sans-serif;
  margin: 10px auto;
  padding: 10px;
  width: 1024px;
  height: 930px;
  background: #eef;
}
#drop-area.highlight {
  border-color: purple;
}
.button {
  display: inline-block;
  padding: 8px;
  background: #bbc;
  cursor: pointer;
  border-radius: 5px;
  border: 3px solid #334;
  z-index:1;
  position:relative;
  font-size: 14px;
}
.button:hover {
  background: #cce;
}
#main-canvas {
  z-index:0;
  border: 2px solid #000;
  border-radius: 20px;
  position: relative;
  left:-2px;
  background: #000;
  margin: 0px;
  box-shadow: 0 0 5px black;
}
#gui {
 position: relative;
 top: -230px;
 right: -6px;
}
.dg {
  color: #f55;
  text-shadow: none !important;
}
.dg .c input[type=text] {
  background: #e9e9e9;
}
</style>

</head>

<body onload="main();">

<div id="drop-area">
  <form class="my-form">
    <input type="file" id="FileElmt" style='display:none;'
           multiple accept="image/*" onchange="HandleFile(this.files[0])">
  </form>
  <div height='150px'>
    <h2><center>Weighted Linde-Buzo-Gray Stippling Demo [WIP]</center></h2>
    Stippling tool, as described in
    <a href="http://graphics.uni-konstanz.de/publikationen/Deussen2017LindeBuzoGray/WeightedLindeBuzoGrayStippling_authorversion.pdf">this paper</a>
    by O. Deussen, M. Spicker and Q. Zheng. [<a href="https://github.com/MarcSpicker/LindeBuzoGrayStippling">github repo</a>]
    <br/>
    <br/>
    <font size='-1'>Drag and drop image on the canvas below.</font>
  </div>
  <div>
    <button class='button' style='top:70px; left:30px;'
          onmousedown="params.use_original=true; Render();"
          onmouseup="params.use_original=false; Render();">show original</button>
    <label class='button' for="FileElmt"
           style='top:70px; left:750px;'>select an image</label>
  </div>
  <div id="gui-container">
    <canvas id="main-canvas" width='1024px' height='750px'></canvas>
  </div>
  <form action="https://skal65535.github.io/"
        style='position: relative; top:-10px; left:950px;'>
    <input type="submit" value="skal 2023" id="skal-2023"
           style='border-radius: 5px; padding: 5px; 
                  background: #cce; border: 1px solid #112;'
      onmouseover='this.style.background="#cdf"'
      onmouseout='this.style.background="#cce"'/>
  </form>
</div>


<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">
attribute vec4 vtx;
uniform vec4 u_view;
varying vec2 uv_coord;
void main() {
  vec2 pos = vtx.xy * u_view.xy - u_view.zw;
  gl_Position = vec4(pos, 0., 1.);
  uv_coord = vtx.zw;
}
</script>

<!-- fragment shaders -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D image;
uniform vec4 u_view;
uniform vec2 iSize;
uniform vec2 Params;
uniform int GrayScale;

varying vec2 uv_coord;

void main() {
  vec3 sum = vec3(0.);
  vec3 col = texture2D(image, uv_coord).rgb;
  float amp = 0.25 * (1. - Params.x);
  for (float i = -1.; i <= 1.; i += 2.) {
    col -= amp * texture2D(image, uv_coord + vec2(i * iSize.x, 0.)).rgb;
    col -= amp * texture2D(image, uv_coord + vec2(0., i * iSize.y)).rgb;
  }
  vec3 diff = Params.y * abs(col);
  if (GrayScale > 0) diff = vec3(dot(diff, vec3(.2126, 0.7152, 0.0722)));
  gl_FragColor = vec4(min(diff, 1.), 1.);
}
</script>

<script  id="fragment-shader-basic" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D image;
varying vec2 uv_coord;
void main() { gl_FragColor = texture2D(image, uv_coord); }
</script>

<!-- <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

<script>
"use strict";

////////////////////////////////////////////////////////////////////////////////
// DoG: The interesting stuff

const params = {  // Global parameters
  alpha: 0.,
  strength: 1.,
  use_grayscale: false,
  use_original: false,
  image: null,
  gui: null,
}

////////////////////////////////////////////////////////////////////////////////
// Drag'n'Drop

function PreventDefaults (e) {
  e.preventDefault();
  e.stopPropagation();
}
function HandleDrop(e) {
  HandleFile(e.dataTransfer.files[0]);
}
function HandleFile(file) {
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onloadend = function() {
    params.image = new Image();
    params.image.onload = function() { Render(); };
    params.image.src = reader.result;
  }
}
function SetupDragAndDrop() {
  const dropArea = document.getElementById('drop-area');
  function highlight(e) { dropArea.classList.add('highlight'); }
  function unhighlight(e) { dropArea.classList.remove('highlight'); }

  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, PreventDefaults, false); }
  );
  ['dragenter', 'dragover'].forEach(
    name => { dropArea.addEventListener(name, highlight, false); }
  );
  ['dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, unhighlight, false); }
  );
  dropArea.addEventListener('drop', HandleDrop, false)
}

////////////////////////////////////////////////////////////////////////////////

function SetupUI() {
  params.gui = new dat.GUI();
  params.gui.domElement.id = 'gui';
  params.gui.add(params, 'alpha', 0.0, 1.0, .01).name('blend w/ source')
            .listen().onChange(Render);
  params.gui.add(params, 'strength', 1.0, 16., .01).name('strength')
            .listen().onChange(Render);
  params.gui.add(params, 'use_grayscale').name('use grayscale')
            .listen().onChange(Render);
  const canvas = document.getElementById('gui-container');
  canvas.appendChild(params.gui.domElement);
}

////////////////////////////////////////////////////////////////////////////////
// Main WebGL calls

function main() {
  params.image = new Image();
  params.image.src = "./input1.webp";
  params.image.onload = function() { Render(); };

  SetupDragAndDrop();
  SetupUI();
}

function CreateShader(gl, type, src_id) {
  const shader = gl.createShader(type);
  const src = document.getElementById(src_id).text;
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!compiled) {
    const error = gl.getShaderInfoLog(shader);
    console.log('*** Shader Compile Error \'' + src_id + '\':' + error + '\n');
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function CreateShaders(gl, v_shader_id, f_shader_id) {
  const f_shader = CreateShader(gl, gl.FRAGMENT_SHADER, f_shader_id);
  const v_shader = CreateShader(gl, gl.VERTEX_SHADER, v_shader_id);
  const shader_program = gl.createProgram();
  gl.attachShader(shader_program, f_shader);
  gl.attachShader(shader_program, v_shader);
  gl.linkProgram(shader_program);
  gl.useProgram(shader_program);
  return shader_program;
}

function Render() {
  const image = params.image;
  const canvas = document.querySelector("#main-canvas");
  let Wo = canvas.width, Ho = canvas.height;
  let W = image.width, H = image.height;
  if (W > Wo || H > Ho) {   // needs resizing?
    if (W * Ho > Wo > H) {
      H = Math.floor(H * Wo / W);
      W = Wo;
    } else {
      W = Math.floor(W * Ho / H);
      H = Ho;
    }
  }
  image.width = W;
  image.height = H;
  RenderWithGL();
}

function RenderWithGL() {
  const canvas = document.querySelector("#main-canvas");
  const image = params.image;
  const W = image.width, H = image.height, Wo = canvas.width, Ho = canvas.height;
  const gl = canvas.getContext("webgl");
  if (!gl) return;

  gl.viewport(0, 0, Wo, Ho);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  const program = CreateShaders(gl,
    "vertex-shader-2d",
    params.use_original ? "fragment-shader-basic" : "fragment-shader-2d");

  // rectangle the same size as the image.
  const vtxBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vtxBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([  // x,y, u,v
     0, 0, 0., 0.,
     W, 0, 1., 0.,
     0, H, 0., 1.,
     0, H, 0., 1.,
     W, 0, 1., 0.,
     W, H, 1., 1.
  ]), gl.STATIC_DRAW);
  const vtxLocation = gl.getAttribLocation(program, "vtx");
  gl.enableVertexAttribArray(vtxLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, vtxBuffer);
  gl.vertexAttribPointer(vtxLocation, 4, gl.FLOAT,
                         /*normalize=*/false, /*stride=*/0, /*offset=*/0);

  // upload image to texture
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  // uniforms setup
  const kView = gl.getUniformLocation(program, "u_view");
  const iSize = gl.getUniformLocation(program, "iSize");
  const kParams = gl.getUniformLocation(program, "Params");
  const kGrayScale = gl.getUniformLocation(program, "GrayScale");
  gl.uniform4f(kView, 2. / Wo, -2. / Ho, W / Wo, -H / Ho);
  gl.uniform2f(iSize, 1. / W, 1. / H);
  gl.uniform2f(kParams, params.alpha, params.strength);
  gl.uniform1i(kGrayScale, params.use_grayscale ? 1 : 0);

  // go!
  gl.drawArrays(gl.TRIANGLES, /*offset=*/0, /*count=*/6);
}
</script>

</body>
</html>
