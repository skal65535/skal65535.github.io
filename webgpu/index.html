<!-- skal/ (pascal.massimino@gmail.com) 2023 -->
<!DOCTYPE html>
<html>

<head>
<title>WebGPU test</title>

</head>

<body onload="init();">

<body>
<div>
  <center>
    <canvas id="canvas" style='outline: 1px solid black;'></canvas><br/>
    Ball simulation with WebGPU (WIP)
  </center>
</div>

<script>
"use strict";

const args = new URLSearchParams(location.search);

function parse_arg_f(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseFloat(args.get(arg_value))
        : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}
function parse_arg_i(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseInt(args.get(arg_value))
        : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}

const params = {
  balls: parse_arg_i("balls", 10000, 1, 1000000),
  min_r: parse_arg_f("min_radius", 2., 1., 100.),
  max_r: parse_arg_f("max_radius", 5., 1., 100.),
  render: parse_arg_i("render", 1),
  dt: parse_arg_f("dt", 0.003, 1e-6, .1),
  gravity: parse_arg_f("g", 10.),
  collisions: parse_arg_i("collisions", 1, 0, 1),
}
const ctx = document.querySelector("#canvas").getContext("webgpu");

let textureFormat = 'bgra8unorm';
let W = parse_arg_i("width", 500);
let H = parse_arg_i("height", 500);
ctx.canvas.width  = W;
ctx.canvas.height = H;

function onResize(device) {
//  W = Math.ceil(window.innerWidth * window.devicePixelRatio);
//  H = Math.ceil(window.innerHeight * window.devicePixelRatio);
  canvas.width = W;
  canvas.height = H;
  ctx.configure({device: device,
                 format: textureFormat,
                 usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                 alphaMode: 'premultiplied'});
  console.log("On Resize: " + W + "x" + H);
}

const FLOAT32_SIZE = Float32Array.BYTES_PER_ELEMENT;

function RandomRange(a, b) { return Math.random() * (b - a) + a; }

function init_balls(device) {
  const BUFFER_SIZE = params.balls * 6 * FLOAT32_SIZE;
  let balls = new Float32Array(new ArrayBuffer(BUFFER_SIZE));
  for (let i = 0; i < params.balls; ++i) {
    balls[i * 6 + 0] = RandomRange( 0.0, 1.);  // position.x
    balls[i * 6 + 1] = RandomRange( 0.0, 1.);  // position.y
    balls[i * 6 + 2] = RandomRange(-1.0, 1.);  // velocity.x
    balls[i * 6 + 3] = RandomRange(-1.0, 1.);  // velocity.y
    balls[i * 6 + 4] = RandomRange(params.min_r, params.max_r) / 200.; // radius
    balls[i * 6 + 5] = RandomRange( 0.2, 1.);  // brightness
  }
  const buffer = device.createBuffer({
    size: balls.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
    mappedAtCreation: true,
  });
  new Float32Array(buffer.getMappedRange()).set(balls);
  buffer.unmap();
  return buffer;
}

async function init() {
  if (!navigator.gpu) throw Error("WebGPU not supported.");
  console.log("Navigator has GPU");

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) throw Error("Couldn’t request WebGPU adapter.");
  console.log("Adapter ok");

  const device = await adapter.requestDevice();
  if (!device) throw Error("Couldn’t request WebGPU logical device.");
  console.log("Device acquired");

  textureFormat = navigator.gpu.getPreferredCanvasFormat();
  onResize(device);  // <- will configure() the ctx
  window.addEventListener('resize', () => onResize(device), false);

  const uniforms_struct_code = `
    struct Uniforms {
      dim: vec2<f32>,   // dimension W x H
      dt: f32,
      gravity: f32,
      num_balls: f32,
      pad1: f32,
      pad2: f32,
      pad3: f32,
    }
  `;
  const ball_struct_code = `
    struct Ball {
      position: vec2<f32>,
      velocity: vec2<f32>,
      radius:   f32,
      brightness: f32,
    }
    struct Balls {
      balls: array<Ball>,
    }
  `;

  // COMPUTE pipeline, updating the particles' positions / velocity
  const update_module = device.createShaderModule({
    code: `
      ${ball_struct_code}
      ${uniforms_struct_code}

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read_write> balls: Balls;

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
        let num_balls = uniforms.num_balls;
        let idx = global_id.x;
        if (f32(idx) >= num_balls) { return; }
        var b = balls.balls[idx];
        let dt = uniforms.dt;
        let g = uniforms.gravity;
        let R = b.radius;
        var spd = b.velocity + dt * vec2(0., g);
        var pos = b.position + dt * spd;
        if (pos.x < R) { pos.x = 2. * R - pos.x; spd.x = -spd.x; }
        if (pos.x > 1. - R) { pos.x = 2. * (1. - R) - pos.x; spd.x = -spd.x; }
        if (pos.y < R) { pos.y = 2. * R - pos.y; spd.y = -spd.y; }
        if (pos.y > 1. - R) { pos.y = 2. * (1. - R) - pos.y; spd.y = -spd.y; }
        b.position = pos;
        b.velocity = spd;

        balls.balls[idx] = b;
      }
    `,
  });

  const update_pipeline = device.createComputePipeline({
    layout: "auto",
    compute: {
      module: update_module,
      entryPoint: "main",
    },
  });

  // RENDER pipeline drawing the particles
  const particles_code = `
      ${uniforms_struct_code}

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) color: vec4<f32>,
        @location(1) center: vec2<f32>,
        @location(2) radius: f32,
      };

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;

      @vertex
      fn vtx_main(
          @builtin(vertex_index) vtx_idx: u32,
          @builtin(instance_index) instance_idx: u32,
          @location(0) pos: vec2<f32>,
          @location(1) spd: vec2<f32>,
          @location(2) radius: vec2<f32>,
      ) -> VertexOutput {
        var kVtxCoords = array<vec2<f32>, 3>(  // arrow shape
          vec2<f32>( 0., -1.),
          vec2<f32>( 1.,  1.),
          vec2<f32>(-1.,  1.),
        );
        let vtx = kVtxCoords[vtx_idx];
        let center = pos.xy * vec2<f32>(2., -2.) + vec2<f32>(-1., 1.);
        let R = radius.x;
        var output : VertexOutput;
        output.position = vec4<f32>(center + vtx * R, 0., 1.);
        let gray = radius.y * .3;
        output.color = vec4<f32>(gray, gray, 1. - gray, 1.);
        output.center = pos.xy;
        output.radius = R * 400.;
        return output;
      }

      @fragment
      fn frag_main(
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec4<f32>,
          @location(1) center: vec2<f32>,
          @location(2) radius: f32,
      ) -> @location(0) vec4<f32> {
        var pos = center.xy * uniforms.dim;
        var d = 1. - smoothstep(0., radius, length(position.xy - pos));
        return color * d;
      }
  `;
  const particles_module = device.createShaderModule({code: particles_code});

  const particles_pipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: particles_module,
      entryPoint: 'vtx_main',
      buffers: [
        { arrayStride: 6 * FLOAT32_SIZE,
          stepMode: 'instance',
          attributes: [
            { shaderLocation: 0, offset: 0 * FLOAT32_SIZE, format: 'float32x2', },  // x, y
            { shaderLocation: 1, offset: 2 * FLOAT32_SIZE, format: 'float32x2', },  // dx, dy
            { shaderLocation: 2, offset: 4 * FLOAT32_SIZE, format: 'float32x2', },  // radius, brightness
          ],
        },
      ],
    },
    fragment: {
      module: particles_module,
      entryPoint: 'frag_main',
      targets: [{
        format: textureFormat,
        blend: {
          color: {srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add'},
          alpha: {srcFactor: 'zero',      dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: { topology: 'triangle-list', },
  });

  // Create the data buffers and the binding groups
  const balls_buffer = init_balls(device);

  const uniforms_buffer = device.createBuffer({
    size: 8 * FLOAT32_SIZE,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  // write the uniforms once for all
  device.queue.writeBuffer(uniforms_buffer, 0,
      new Float32Array([
        W, H,  /* <- dim */
        params.dt, params.gravity, params.balls,
      ]));

  // create bind groups
  const update_bind_group = device.createBindGroup({
    layout: update_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniforms_buffer, }, },
      { binding: 1, resource: { buffer: balls_buffer, }, },
    ],
  });
  const particles_bind_group = device.createBindGroup({
    layout: particles_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniforms_buffer, }, },
    ],
  });

  // main loop
  function frame() {
    performance.mark("webgpu start");
    const encoder = device.createCommandEncoder();

    const compute_pass = encoder.beginComputePass();
    compute_pass.setPipeline(update_pipeline);
    compute_pass.setBindGroup(0, update_bind_group);
    compute_pass.dispatchWorkgroups(Math.ceil(balls_buffer.size / 64));
    compute_pass.end();

    const textureView = ctx.getCurrentTexture().createView();

    const render_pass = encoder.beginRenderPass({
      colorAttachments: [
        { view: textureView,
          clearValue: {r:0., g:0., b:0., a:1.}, loadOp: 'clear',
          storeOp: 'store', }
      ]});
    render_pass.setPipeline(particles_pipeline);
    render_pass.setBindGroup(0, particles_bind_group);
    render_pass.setVertexBuffer(0, balls_buffer);
    render_pass.draw(3, params.balls, 0, 0);
    render_pass.end();

    device.queue.submit([encoder.finish()]);

    performance.mark("webgpu end");

    performance.measure("webgpu", "webgpu start", "webgpu end");
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

</script>

</body>
</html>
