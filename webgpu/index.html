<!-- skal/ (pascal.massimino@gmail.com) 2023 -->
<!DOCTYPE html>
<html>

<head>
<title>WebGPU test</title>

</head>

<body onload="init();">

<body>
<div>
  <center>
    <canvas id="canvas" style='outline: 1px solid black;'></canvas><br/>
    Ball simulation with WebGPU (WIP)
  </center>
</div>

<script>
"use strict";

const args = new URLSearchParams(location.search);

function parse_arg_f(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseFloat(args.get(arg_value))
        : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}
function parse_arg_i(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseInt(args.get(arg_value))
        : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}

const params = {
  balls: parse_arg_i("balls", 10000, 1, 1000000),
  min_r: parse_arg_f("min_radius", 2., 1., 100.),
  max_r: parse_arg_f("max_radius", 5., 1., 100.),
  render: parse_arg_i("render", 1),
  dt: parse_arg_f("dt", 0.003, 1e-6, .1),
  gravity: parse_arg_f("g", 10.),
}
const ctx = document.querySelector("#canvas").getContext("webgpu");
const textureFormat = 'bgra8unorm';

let W = parse_arg_i("width", 500);
let H = parse_arg_i("height", 500);
ctx.canvas.width  = W;
ctx.canvas.height = H;

function onResize(device) {
//  W = Math.ceil(window.innerWidth * window.devicePixelRatio);
//  H = Math.ceil(window.innerHeight * window.devicePixelRatio);
  canvas.width = W;
  canvas.height = H;
  ctx.configure({device: device,
                 format: textureFormat,
                 usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                 alphaMode: 'premultiplied'});
  console.log("On Resize: " + W + "x" + H);
}

const FLOAT32_SIZE = Float32Array.BYTES_PER_ELEMENT;
const BUFFER_SIZE = params.balls * 6 * FLOAT32_SIZE;

function randomBetween(a, b) {
  return Math.random() * (b - a) + a;
}

function init_balls(device) {
  let balls = new Float32Array(new ArrayBuffer(BUFFER_SIZE));
  for (let i = 0; i < params.balls; ++i) {
    balls[i * 6 + 0] = randomBetween(params.min_r, params.max_r) / 100.; // radius
    balls[i * 6 + 1] = randomBetween(0.2, 1.); // brightness
    balls[i * 6 + 2] = randomBetween(0., 1.);  // position.x
    balls[i * 6 + 3] = randomBetween(0., 1.);  // position.y
    balls[i * 6 + 4] = randomBetween(-1., 1.); // velocity.x
    balls[i * 6 + 5] = randomBetween(-1., 1.); // velocity.y

    balls[i * 6 + 2] = ((i % 30) + 2.) / 32.;
    balls[i * 6 + 3] = (Math.floor(i / 30) + 2.) / 32.;
  }
  const buffer = device.createBuffer({
    size: balls.byteLength,
    usage: GPUBufferUsage.VERTEX |
           GPUBufferUsage.STORAGE |
           GPUBufferUsage.COMPUTE,
    mappedAtCreation: true,
  });
  new Float32Array(buffer.getMappedRange()).set(balls);
  buffer.unmap();
  return buffer;
}

function animate() {
  return new Promise(e => requestAnimationFrame(e));
}

async function init() {
  if (!navigator.gpu) throw Error("WebGPU not supported.");
  console.log("Navigator has GPU");

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) throw Error("Couldn’t request WebGPU adapter.");
  console.log("Adapter ok: " + adapter.limits.maxSamplersPerShaderStage);

  const device = await adapter.requestDevice();
  if (!device) throw Error("Couldn’t request WebGPU logical device.");
  console.log("Device acquired");

  onResize(device);  // <- will configure() the ctx
  window.addEventListener('resize', () => onResize(device), false);

  const uniforms_struct_code = `
    struct Uniforms {
      bg_color: vec4<f32>,
      width: f32,
      height: f32,
      dt: f32,
      gravity: f32,
      num_balls: f32,
      pad1: f32,
      pad2: f32,
      pad3: f32,
    }
  `;
  const ball_struct_code = `
    struct Ball {
      radius:   f32,
      brightness: f32,
      position: vec2<f32>,
      velocity: vec2<f32>,
    }
    struct Balls {
      balls: array<Ball>,
    }
  `;

  // COMPUTE pipeline, updating the particles' positions / velocity
  const update_module = device.createShaderModule({
    code: `
      ${ball_struct_code}
      ${uniforms_struct_code}

      @group(0) @binding(0) var<storage, read_write> balls: Balls;
      @group(0) @binding(1) var<uniform> uniforms: Uniforms;

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
        let num_balls = uniforms.num_balls;
        let idx = global_id.x;
        if (f32(idx) >= num_balls) { return; }
        var b = balls.balls[idx];
        let dt = uniforms.dt;
        let g = uniforms.gravity;
        let R = b.radius;
        var spd = b.velocity + dt * vec2(0., g);
        var pos = b.position + dt * spd;
        if (pos.x < R) { pos.x = 2. * R - pos.x; spd.x = -spd.x; }
        if (pos.x > 1. - R) { pos.x = 2. * (1. - R) - pos.x; spd.x = -spd.x; }
        if (pos.y < R) { pos.y = 2. * R - pos.y; spd.y = -spd.y; }
        if (pos.y > 1. - R) { pos.y = 2. * (1. - R) - pos.y; spd.y = -spd.y; }

        b.position = pos;
        b.velocity = spd;

        balls.balls[idx] = b;
      }
    `,
  });

  const update_bind_group_layout = device.createBindGroupLayout({
    entries: [
      { binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: "storage", }, },
      { binding: 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: "uniform", }, },
    ],
  });

  const update_pipeline = device.createComputePipeline({
    compute: {
      module: update_module,
      entryPoint: "main",
    },
    layout: device.createPipelineLayout({
      bindGroupLayouts: [update_bind_group_layout],
    }),
  });

  // RENDER pipeline clearing the background.
  const bg_shader_module = device.createShaderModule({
    code: `
      ${uniforms_struct_code}

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;

      @vertex
      fn vtx_main(@builtin(vertex_index) vtx_idx: u32,)
          -> @builtin(position) vec4<f32> {
        var kVtxCoords = array<vec4<f32>, 3>(
          vec4<f32>(-1.0, -1.0, 0.0, 1.0),
          vec4<f32>( 3.0, -1.0, 0.0, 1.0),
          vec4<f32>(-1.0,  3.0, 0.0, 1.0),
        );
        return kVtxCoords[vtx_idx];
      }
      @fragment
      fn frag_main(@builtin(position) position: vec4<f32>,)
          -> @location(0) vec4<f32> {
        return vec4<f32>(uniforms.bg_color);
      }
    `,
  });
  const bg_bind_group_layout = device.createBindGroupLayout({
    entries: [
      { binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: { type: "uniform", }, },
    ],
  });

  const bg_pipeline = device.createRenderPipeline({
    vertex: {
      module: bg_shader_module,
      entryPoint: 'vtx_main',
    },
    fragment: {
      module: bg_shader_module,
      entryPoint: 'frag_main',
      targets: [{format: textureFormat}],
    },
    primitive: {
      topology: 'triangle-list',
    },
    layout: device.createPipelineLayout({
      bindGroupLayouts: [bg_bind_group_layout],
    }),
  });

  // RENDER pipeline drawing the particles
  const particles_code = `
      ${ball_struct_code}
      ${uniforms_struct_code}

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) color: vec4<f32>,
        @location(1) center: vec2<f32>,
      };

      @group(0) @binding(0) var<storage, read_write> balls: Balls;
      @group(0) @binding(1) var<uniform> uniforms: Uniforms;

      @vertex
      fn vtx_main(
          @builtin(vertex_index) vtx_idx: u32,
          @builtin(instance_index) instance_idx: u32,
          @location(0) radius: vec2<f32>,
          @location(1) pos: vec2<f32>,
          @location(2) spd: vec2<f32>,
      ) -> VertexOutput {
        var kVtxCoords = array<vec2<f32>, 3>(  // arrow shape
          vec2<f32>( 0., -1.),
          vec2<f32>( 1.,  1.),
          vec2<f32>(-1.,  1.),
        );
        let vtx = kVtxCoords[vtx_idx];
        let center = pos.xy * vec2<f32>(2., -2.) + vec2<f32>(-1., 1.);
        let R = radius.x;
        var output : VertexOutput;
        output.position = vec4<f32>(center + vtx * R, 0., 1.);
        let gray = radius.y * .3;
        output.color = vec4<f32>(gray, gray, 1. - gray, 1.);
        output.center = pos.xy;
        return output;
      }

      @fragment
      fn frag_main(
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec4<f32>,
          @location(1) center: vec2<f32>,
      ) -> @location(0) vec4<f32> {
        var pos = center.xy * vec2<f32>(uniforms.width, uniforms.height);
        var d = 1. - smoothstep(0., 10., length(position.xy - pos));
        return color * d;
      }
  `;
  const particles_module = device.createShaderModule({code: particles_code});

  const particles_bind_group_layout = device.createBindGroupLayout({
    entries: [
      { binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: { type: "read-only-storage", }, },
      { binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: { type: "uniform", }, },
    ],
  });

  const particles_pipeline = device.createRenderPipeline({
    vertex: {
      module: particles_module,
      entryPoint: 'vtx_main',
      buffers: [
        { arrayStride: 6 * FLOAT32_SIZE,
          stepMode: 'instance',
          attributes: [
            { shaderLocation: 0, offset: 0 * FLOAT32_SIZE, format: 'float32x2', },  // Radius + Brightness
            { shaderLocation: 1, offset: 2 * FLOAT32_SIZE, format: 'float32x2', },  // x,y
            { shaderLocation: 2, offset: 4 * FLOAT32_SIZE, format: 'float32x2', },  // dx,dy
          ],
        },
      ],
    },
    fragment: {
      module: particles_module,
      entryPoint: 'frag_main',
      targets: [{
        format: textureFormat,
        blend: {
          color: {srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add'},
          alpha: {srcFactor: 'zero',      dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: {
      topology: 'triangle-list',
    },
    layout: device.createPipelineLayout({
      bindGroupLayouts: [particles_bind_group_layout],
    }),
  });

  const balls_buffer = init_balls(device);

  const uniforms = device.createBuffer({
    size: 12 * FLOAT32_SIZE,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  // write the uniforms once for all
  device.queue.writeBuffer(uniforms, 0,
      new Float32Array([.00, .01, .10, 1.,
                        W, H, params.dt, params.gravity,
                        params.balls,
                        0, 0, 0,
                       ]));
  const update_bind_group = device.createBindGroup({
    layout: update_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: balls_buffer, }, },
      { binding: 1, resource: { buffer: uniforms }, },
    ],
  });
  const bg_bind_group = device.createBindGroup({
    layout: bg_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uniforms, }, },
    ],
  });
  const particles_bind_group = device.createBindGroup({
    layout: particles_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: balls_buffer, }, },
      { binding: 1, resource: { buffer: uniforms, }, },
    ],
  });

  // the main loop
  for (;;) {
    performance.mark("webgpu start");
    const encoder = device.createCommandEncoder();

    const compute_pass = encoder.beginComputePass();
    compute_pass.setPipeline(update_pipeline);
    compute_pass.setBindGroup(0, update_bind_group);
    compute_pass.dispatchWorkgroups(Math.ceil(BUFFER_SIZE / 64));
    compute_pass.end();

    const textureView = ctx.getCurrentTexture().createView();
    const bg_pass = encoder.beginRenderPass({
      colorAttachments: [
        { view: textureView, loadValue: {r: 0., g: 0., b: 0., a: 1.},
          loadOp: 'clear', storeOp: 'store', }
      ],});
    bg_pass.setPipeline(bg_pipeline);
    bg_pass.setBindGroup(0, bg_bind_group);
    bg_pass.draw(3, 1, 0, 0);
    bg_pass.end();

    const render_pass = encoder.beginRenderPass({
      colorAttachments: [
        { view: textureView, loadValue: {r: 0., g: 0., b: 0., a: 1.},
          loadOp: 'load', storeOp: 'store', }
      ]});
    render_pass.setPipeline(particles_pipeline);
    render_pass.setBindGroup(0, particles_bind_group);
    render_pass.setVertexBuffer(0, balls_buffer);
    render_pass.draw(3, params.balls, 0, 0);
    render_pass.end();

    device.queue.submit([encoder.finish()]);

    performance.mark("webgpu end");

    performance.measure("webgpu", "webgpu start", "webgpu end");
    await animate();
  }
}

</script>

</body>
</html>
