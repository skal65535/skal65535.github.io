<!-- skal/ (pascal.massimino@gmail.com) 2024 -->
<!-- CVM algorithm demo -->

<!DOCTYPE html>
<html>

<head>
<title>CVM algorithm</title>
<link rel="stylesheet" href="../splats/style.css">
</head>

<body onload="read_text(0);">
<h1><a href='https://medium.com/@yourfuse/optimize-memory-and-performance-with-the-cvm-algorithm-in-javascript-a-comprehensive-guide-for-6bb33d1a5b63'>CVM algorithm</a> demo</h1>

Original <a href='https://arxiv.org/abs/2301.10191'>paper</a>.
Quanta Magazine <a href='https://www.quantamagazine.org/computer-scientists-invent-an-efficient-new-way-to-count-20240516/'>article</a>.

<div>
  <input type='button' onchange='process_text();' value='GO!'><br/>
  <input type="range" min="1" max="10000" value="50" id="max_size" 
    oninput="params.set_max_size(this.value);"
    onchange="main();">
  Max buffering size for unique words: <span id="max_size_value"></span><br/>
  <input type="range" min="0." max="100." value="50." id="reject_proba"
    oninput="params.set_reject_proba(this.value / 100.);"
    onchange="main();">
  Rejection proba: <span id="reject_proba_value">.5</span><br/>  
</div>
<textarea id="input" name="input" rows="20" cols="80" onchange='main();'>
'Tis sweet and commendable in your nature, Hamlet,
To give these mourning duties to your father:
But, you must know, your father lost a father;
...
</textarea><br/>
You can copy-paste the entire 'Hamlet' play above from <a href='https://shakespeare.mit.edu/hamlet/full.html'>this page</a>.
<br/>
<input type='button' onclick='read_text(0);' value='Hamlet'>
<input type='button' onclick='read_text(1);' value='DNA sequence'>
<p>
<canvas id="histo" width="400" height="200"></canvas><br/>
<input type="range" min="10" max="40" value="20" id="nb_bins"
  oninput="params.set_nb_bins(this.value); Draw();"
  onchange="params.set_nb_bins(this.value); Draw();">
  number of bins: <span id="nb_bins_value"></span>
</p>

<script>
const read_text = async (what) => {
  const url = (what == 0) ? "https://gist.githubusercontent.com/provpup/2fc41686eab7400b796b/raw/b575bd01a58494dfddc1d6429ef0167e709abf9b/hamlet.txt"
                          : "https://skal65535.github.io/CVM/DNA.txt";
  console.log(url);
  await fetch(url).then(r => r.text()).then(
    (t) => {
      console.log("Got text!", t.length);
      document.getElementById('input').innerHTML = t;
      main();
    });
};

let params = {
  text: [],
  nb_bins: 20,
  max_size: 500,
  reject_proba: .5,

  set_nb_bins: (v) => { params.nb_bins = v; document.getElementById("nb_bins_value").innerHTML = v; },
  set_max_size: (v) => { params.max_size = v; document.getElementById("max_size_value").innerHTML = v; },
  set_reject_proba: (v) => { params.reject_proba = v; document.getElementById("reject_proba_value").innerHTML = v; },

  nb_updates: 100,
  total_updates: 100 * 100,

  // run-time:
  results: [],
  expected_size: 0,
  id: -1,   // interval
  total: 0,
  avg_rounds: 0,
};

function FlipCoins(p) { return (Math.random() < p); }

function CVM(words, max_size, reject_proba) {
  let proba = 1.;
  let round = 0;
  const words_set = new Set();
  for (const w of words) {
    words_set.delete(w);
    if (Math.random() < proba) words_set.add(w);
    if (words_set.size == max_size) {
      const words_array = Array.from(words_set);
      words_set.clear();
      for (const W of words_array) {
        if (Math.random() < reject_proba) words_set.add(W);
      };
      proba *= reject_proba;
      ++round;
    }
  }
  return [round, Math.floor(words_set.size / proba)];
}

function CountUniqueWords(words) {
  let s = new Set();
  for (let w of words) s.add(w);
  return s.size;
}

function main() {
  params.set_nb_bins(document.getElementById("nb_bins").value);
  params.set_max_size(document.getElementById("max_size").value);
  params.set_reject_proba(document.getElementById("reject_proba").value / 100.);
  process_text();
}

function ChangeText() {
  let text = document.getElementById("input").value;
  params.text = text.match(/\b\w+\b/g).map(x => x.toLowerCase()) || [];
  params.expected_size = CountUniqueWords(params.text);
  params.results = [];
}

/////////// VISU ///////////

function Deviation() {
  let dev = 0., sum = 0., num = 0.;
  for (const x of params.results) {
    const delta = x - params.expected_size;
    dev += x * x;
    sum += x;
    num += 1.;
  }
  if (num > 1.) dev = (dev - sum * sum / num) / (num - 1.);
  return Math.floor(Math.sqrt(dev) * 10.) / 10.;
}

function Draw() {
  let xmin = 1e8, xmax = -1e8;
  for (const x of params.results) {
    xmin = Math.min(xmin, x);
    xmax = Math.max(xmax, x);
  }
  if (xmin > xmax) {
    console.log("!? xmin/max error", xmin, xmax);
    return;
  }
  xmax += 1.;
  xmin -= 1.;
  const delta = 1. / (xmax - xmin);
  const nb_bins = Math.min(xmax + 1 - xmin, params.nb_bins);
  let bins = new Array();
  bins.length = nb_bins;
  bins.fill(0);
  function bin(v) {
    return Math.round((v - xmin) * (bins.length - 1) * delta);
  }

  for (const x of params.results) {
    const X = bin(x);
    ++bins[X];
  }

  let ymax = 0;
  for (const b of bins) ymax = Math.max(ymax, b);
  if (ymax == 0) {
    console.log("!? ymax error", ymax);
    return;
  }

  console.log("Draw", nb_bins, xmin, xmax, ymax, params.expected_size);

  const canvas = document.querySelector("#histo");
  const W = canvas.width;
  const H = canvas.height;
  const ctx = canvas.getContext('2d');
  canvas.style.display = 'inline-block';
  ctx.font = "bold 15px Arial";

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#136';
  const unit = W / bins.length;
  const max_h = H - 20;
  const max_w = Math.max(1., unit - 1.);
  for (let n = 0; n < bins.length; ++n) {
    const v = bins[n] * H / ymax;
    ctx.fillRect(n * unit, max_h - v, max_w, v);
  }
  ctx.fillStyle = '#f33';

  const N = bin(params.expected_size);
  ctx.fillRect(N * unit, 5, unit / 2., max_h - 5);
  ctx.fillText(params.expected_size + '(expected)', (N + 1.3) * unit, 15);

  const dev = Deviation();
  ctx.fillStyle = '#000';
  ctx.fillText('sigma:' + dev, 10, 30);
  ctx.fillText('<rounds>:' + params.avg_rounds, 10, 45);

  ctx.fillStyle = '#000';
  const max_ticks = 5;
  for (let n = 0; n < max_ticks; ++n) {
    let v = xmin + n * (xmax - xmin) / max_ticks;
    v = Math.floor(v / 10) * 10;
    const X = (v - xmin) * W * delta;
    ctx.fillText(v, X, max_h + 15);
  }

}

function process_text() {
  params.id = -1;
  ChangeText();

  params.total = params.total_updates;
  params.avg_rounds = 0;
  params.id = window.requestAnimationFrame(Loop);
}

function Loop() {
  const nb_updates = params.nb_updates;
  params.avg_rounds = 0;
  for (let i = 0; i < nb_updates; ++i) {
    const [rounds, size_estimate] = CVM(params.text, params.max_size, params.reject_proba);
    params.results.push(size_estimate);
    params.avg_rounds += rounds;
  }
  params.avg_rounds = Math.floor(params.avg_rounds/ nb_updates * 10.) / 10.;
  Draw();
  params.total -= nb_updates;
  if (params.total > 0 && params.id >= 0) {
    window.requestAnimationFrame(Loop);
  } else {
    params.id = -1;
  }
}

</script>
</body>
</html>
