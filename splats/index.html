<!-- skal/ (pascal.massimino@gmail.com) 2023 -->
<!-- 3DGS renderer in WebGPU (WIP!!) -->

<!DOCTYPE html>
<html>

<head>
<title>Gaussian Splat rendering with WebGPU</title>
</head>

<style>
#drop-area {
  border: 3px dashed #ccc;
  border-radius: 20px;
  margin: 5px auto;
  padding: 5px;
  background: #eef;
}
#canvas {
  z-index:0;
  border: 2px solid #000;
  border-radius: 20px;
  background: #000;
  margin: 0px;
  box-shadow: 0 0 8px black;
}
</style>

<body onload="init_GUI(); init_GPU(); init(true);">

<div id='drop-area'>
  <center>
    <canvas id="canvas" style='outline: 1px solid black;'></canvas><br/>
    <b><a href='https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_low.pdf'>Gaussian Splat</a>
    rendering, using <a href='https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API'>WebGPU</a> (WIP)</b><p>
  </center>
    This WebGPU implementation uses a compute shader to extract the splats'
    parameters (position, axis, color) once for all.<br/>
    The vertex shader generates a well-oriented Quad suitable for vertex indexation.<br/>
    The fragment shader has several 'visu' functions, other than the expected 'gaussian'.
    <i>Try 'cone', it looks good too!</i>
    <ul>
    KNOWN BUGS / LIMITATIONS:
    <li>z-sorting is imperfect, slow (see console with 'print timing'!), and produces flickering. This is the bottleneck.</li>
    <li>Most big models will overflow the max-buffer-size-limit. 'nike', 'plush', 'train' are ok, probably.</li>
    <li>Loading is slow and not streamed.</li>
    <li>No Spherical Harmonics for now.</li>
    </ul>

  <form action="https://skal65535.github.io/"
        style='position: relative; top:-260px; left:20px;'>
    <input type="submit" value="skal 2023" id="skal-2023"
           style='border-radius: 5px; padding: 5px;
                  background: #cce; border: 3px solid #112;'
      onmouseover='this.style.background="#cdf"'
      onmouseout='this.style.background="#cce"'/>
  </form>

</div>

<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18"></script>

<script>
"use strict";

const args = new URLSearchParams(location.search);

function parse_arg_f(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseFloat(args.get(arg_value)) : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}
function parse_arg_i(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseInt(args.get(arg_value)) : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}
function parse_arg_b(arg_value) { return (args.has(arg_value) == true); }

const kVisus = ['gaussian', 'cone', 'hard cone', 'ellipsis', 'square', 'filled', 'axis', 'dot'];
const kModels = ['train', 'nike', 'plush', 'truck', 'garden', 'treehill', 'stump', 'bicycle',
                 'cube', 'filled cube'];
const kSorts = ['CPU', 'GPU (TODO)', 'none'];
const FLOAT32_SIZE = Float32Array.BYTES_PER_ELEMENT;
const params = {
  num_splats: 500,
  splats: undefined,

  fov: 90.,
  radius: 2.5,
  theta: -91.,
  phi: 30.0,
  target: [0., 0., 0.],
  znear: 0.2,
  zfar: 200.,
  model: 'nike',
  random_colors: false,
  auto_rotate: true,
  visu: kVisus[0],
  haze: 1.,
  timing: false,
  use_MSAA: false,
  use_depth: false,
  depth_sort: 'CPU',
  mouse_on: false,
  mouse_x: 0.,
  mouse_y: 0.,

  splats: undefined,
  fps: 0.,
  info: "",
  req_id: -1,
  last_t: 0.,
  tick: 0.,
  record_fps: () => {
    const cur_t = Date.now();
    if (cur_t > params.last_t) {
      const new_fps = 1000. / (cur_t - params.last_t);
      params.fps = Math.round(params.fps * 0.9 + new_fps * 0.1);
      params.last_t = cur_t;
    }
  },

  reset: () => { init(true); },
  change: () => { init(false); },
};

var gui = undefined;
function init_GUI() {
  gui = new lil.GUI({name: 'WebGPU Gaussian Splatting demo'});
  gui.add(params, 'num_splats', 1, 100000, 1).listen().onChange(params.reset).disable();
  gui.add(params, 'fov', 0., 180., 5.).listen().onChange(params.change);
  gui.add(params, 'radius', 0.0001, 100., 0.01).listen().onChange(params.change);
  gui.add(params, 'theta', 0., 360., 1.).listen().onChange(params.change);
  gui.add(params, 'phi', -180., 180., 1.).listen().onChange(params.change);
  gui.add(params, 'haze', 1., 10., 0.1).listen().onChange(params.reset);
  gui.add(params, 'auto_rotate').name('auto rotate').listen().onChange(params.change);
  gui.add(params, 'model', kModels).listen().onChange(params.reset);
  gui.add(params, 'visu', kVisus).listen().onChange(params.change);
  gui.add(params, 'random_colors').name('random colors').listen().onChange(params.reset);
  gui.add(params, 'use_MSAA').name('use multi-sampling').listen().onChange(params.reset);
  gui.add(params, 'depth_sort', kSorts).name('depth sorting algo').listen().onChange(params.reset);
  const dbg_folder = gui.addFolder('Debug');
  dbg_folder.add(params, 'timing').name('print timing').listen();
  dbg_folder.add(params, 'use_depth').name('use depth').listen().onChange(params.reset);
  gui.add(params, 'fps').name('fps').listen().disable();
  gui.add(params, 'info').name('info').listen().disable();
}

function get_GUI_element(name) {
  for (const c of gui.controllers) {
    if (c.property == name) return c;
  }
  return undefined;
}

////////////////////////////////////////////////////////////////////////////////

const canvas = document.querySelector("#canvas");
const ctx = canvas.getContext("webgpu");
const W = parse_arg_i("w", innerWidth * .9);
const H = parse_arg_i("h", innerHeight * .8);
canvas.width  = W;
canvas.height = H;

if (parse_arg_b("dbg")) {
  params.auto_rotate = false;
  params.model = 'nike';
  params.visu = 'gaussian';
  params.num_splats = 50;
  params.radius = 2;
  params.theta = 70.;
  params.phi = 0.;
  params.haze = 1.0;
}

// Mouse handling
window.addEventListener('pointermove', (event) => {
  if (event.target != canvas) return;
//  event.preventDefault();
  const bounds = canvas.getBoundingClientRect();
  const mouse_x = (event.clientX - bounds.left) / canvas.width;
  const mouse_y = (event.clientY -  bounds.top) / canvas.height;
  if (params.mouse_on) {
    params.phi   += (params.mouse_y - mouse_y) * 90.;
    params.theta += (params.mouse_x - mouse_x) * 90.;
  }
  params.mouse_x = mouse_x;
  params.mouse_y = mouse_y;
}, false);
window.addEventListener('pointerdown', (event) => {
  if (event.target == canvas) params.mouse_on = true;
});
window.addEventListener('pointerup', (event) => {
  params.mouse_on = false;
});
window.addEventListener('wheel', (event) => {
  if (event.target != canvas) return;
  event.preventDefault();
  params.radius *= (event.deltaY > 0.) ? 1.05 : 1. / 1.05;
}, { passive: false });

////// File drop (TODO(skal): broken for now!) //////
/*
// File-drop handling
const PreventDefault = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
document.addEventListener("dragenter", PreventDefault);
document.addEventListener("dragover", PreventDefault);
document.addEventListener("dragleave", PreventDefault);
document.addEventListener("drop", (event) => {
  PreventDefault(event);
  console.log("Reading file: " + event.dataTransfer.files[0]);
  DropFile(event.dataTransfer.files[0]);
});
*/

////////////////////////////////////////////////////////////////////////////////
////// WebGPU init //////

function Oops(e) {
  document.body.innerHTML = `Oops! <pre>${e}</pre>`;
  throw Error(e);
}

async function init_GPU() {
  navigator.gpu || Oops("WebGPU not supported.");
  console.log("Navigator has GPU");

  const adapter = await navigator.gpu.requestAdapter();
  adapter || Oops("Couldn’t request WebGPU adapter.");
  console.log("Adapter ok");

  render.device = await adapter.requestDevice();
  render.device || Oops("Couldn’t request WebGPU logical device.");
  console.log("Device acquired");

  function onDeviceError(event) {
    console.log("Something bad happened! Error type: " + event.error.constructor.name);
    console.log("Error message: " + event.error.message);
    if (render.device != undefined) {
      render.device.destroy();
      render.device = undefined;
    }
    params.req_id = -1;  // stop animation
    Oops("Error while constructing WebGPU device");
  }
  render.device.addEventListener('uncapturederror', onDeviceError);

  render.textureFormat = navigator.gpu.getPreferredCanvasFormat();
  ctx.configure({device: render.device,
                 format: render.textureFormat,
                 usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                 alphaMode: 'premultiplied',
                });
}

async function create_pipeline(render) {
  if (render.device == undefined) return;
  const uniforms_struct_code = `
    struct Uniforms {  // 40 * 4 bytes
      // 36 * 4
      view: mat4x4f,
      proj: mat4x4f,
      dim:  vec2f,   // screen dimension
      num_splats: u32,
      haze: f32,

      // 4 * 4 bytes
      focal: vec2f,
      theta: f32,
      phi: f32,
    }
  `;
  const splat_struct_code = `
    struct Splat3D {  // 12*4 bytes per splats
      position: vec4f,          // offset 0
      sigma:    array<f32, 6>,  // covariance matrix, upper half   // offset 4 * 4
      color:    u32,            // packed   offset 10 * 4
      // TODO: SPH
    }
    struct Splats3D {
      splats: array<Splat3D>,
    }
    struct Splat2D {  // 12*4 bytes per splats
      position: vec4f,
      axis:     vec4f,  // 2x2 matrix
      color:    u32,    // packed u8
    }
    struct Splats2D {
      splats: array<Splat2D>,
    }
  `;

  // COMPUTE pipeline, projecting the splats
  const update_module = render.device.createShaderModule({
    code: `
      ${splat_struct_code}
      ${uniforms_struct_code}

      @group(0) @binding(0) var<uniform> params: Uniforms;
      @group(0) @binding(1) var<storage, read> splats: Splats3D;
      @group(0) @binding(2) var<storage, read_write> out_splats: Splats2D;
      @group(0) @binding(3) var<storage, read> sorted_list: array<u32>;

      // Zwicker & Al: https://www.cs.umd.edu/~zwicker/publications/EWASplatting-TVCG02.pdf
      fn get_cov2d(vpos: vec4f, sigma: array<f32, 6>) -> vec3f {
        let focal = 0.5 * params.focal;
        let pz = 1. / vpos.z;
        // Jacobian (adjusted by a 'pz' factor)
        let J = mat4x4f(   // actually mat3x2f
          -focal.x,      0., focal.x * vpos.x * pz, 0.,
                0.,-focal.y, focal.y * vpos.y * pz, 0.,
                0.,      0.,                    0., 0.,
                0.,      0.,                    0., 0.,
        );
        // we'd need to extract mat2x3f from 'view' => T is actually mat3x3f
        let T = transpose(params.view) * J;

        // Vk is actually mat3x3f
        let Vk = mat4x4f(sigma[0], sigma[1], sigma[2], 0.,
                         sigma[1], sigma[3], sigma[4], 0.,
                         sigma[2], sigma[4], sigma[5], 0.,
                               0.,       0.,       0., 0.,
        );
        var cov2d = transpose(T) * Vk * T;

        // low-pass filter: avoid degenerate cases of sub-pixel sizes
        // cov2d[0][0] += 1e-8; cov2d[1][1] += 1e-8;

        // only need the upper 2x2 matrix
        return vec3f(cov2d[0][0], cov2d[1][1], cov2d[0][1]);
      }

      // https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
      fn get_axis(vpos: vec4f, cov2d: vec3f) -> vec4f {
        let dist = 0.5 * (cov2d.x - cov2d.y);
        let trace = (cov2d.x + cov2d.y) * 0.5;
        let det = length(vec2f(dist, cov2d.z));
        let lambda1 = clamp(trace + det, 0., 16383.);
        let lambda2 = clamp(trace - det, 0., 16383.);

        let diag = normalize(vec2f(cov2d.z, det - dist));
        let major = sqrt(lambda1) * diag;
        let minor = sqrt(lambda2) * vec2f(diag.y, -diag.x);

        return vec4f(major, minor);
      }

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id : vec3u) {
        let num_splats = u32(params.num_splats);
        if (global_id.x >= params.num_splats) { return; }
        let idx = sorted_list[global_id.x];
        let b = splats.splats[idx];
        var out: Splat2D;
        let vpos = params.view * b.position;
        out.position = params.proj * vpos;
        out.color = b.color;
        let clip = 1.1 * out.position.w;
        if (any(out.position.xyz > vec3f(clip, clip, clip)) ||
            any(out.position.xyz < vec3f(-clip, -clip, 0.))) {
          out.color = 0u;
        } else {
          let cov2d = get_cov2d(vpos, b.sigma);  // mat2x2 = [x, z][z, y]
          out.axis = get_axis(vpos, cov2d);
        }

        out_splats.splats[global_id.x] = out;

// TODO(later):        out_depth[global_id.x] = vpos.z;
      }
    `,
  });

  render.update_pipeline = render.device.createComputePipeline({
    layout: "auto",
    compute: {
      module: update_module,
      entryPoint: "main",
    },
  });


  // RENDER pipeline drawing the splats
  const SplatOut_struct_code = `
    struct SplatOut {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
        @location(1) @interpolate(flat) color:  vec4f,
    };
  `;

  const vs_splats_code = `
      ${uniforms_struct_code}
      ${SplatOut_struct_code}

      @vertex
      fn vtx_main(
          @builtin(vertex_index) vtx_idx: u32,
          @builtin(instance_index) instance_idx: u32,
          // Splat2D:
          @location(0) position: vec4f,
          @location(1) axis:     vec4f,   // 2x2 matrix
          @location(2) color:    u32,
      ) -> SplatOut {
        const kVtxCoords = array<vec2f, 4>(  // quad [-2,2]x[-2,2]
          vec2f(  2., -2.), vec2f(  2.,  2.),
          vec2f( -2.,  2.), vec2f( -2., -2.),
        );
        var output : SplatOut;
        output.uv = kVtxCoords[vtx_idx];
        let delta = output.uv.x * axis.xy + output.uv.y * axis.zw;
        output.position = position + vec4f(delta, 0., 0.);
        output.color = unpack4x8unorm(color);
        return output;
      }
    `;
  function fs_splats_code(visu_func) {
    const kFuncNames = {
      'ellipsis': 'ellipsis', 'square': 'square', 'filled': 'filled',
      'axis': 'axis', 'dot': 'small_dot', 'cone': 'cone',
      'hard cone': 'hard_cone', 'gaussian': 'gaussian'
    };
    return `
      ${SplatOut_struct_code}

      fn ellipsis(v: vec2f) -> f32 { return step(.9, length(v)) - step(1., length(v)); }
      fn small_dot(v: vec2f) -> f32 { return 1. - step(.1, length(v)); }
      fn square(v: vec2f) -> f32 { return smoothstep(0.96, 1.00, max(abs(v.x), abs(v.y))); }
      fn axis(v: vec2f) -> f32 { return 1. - smoothstep(0.00, .05, min(abs(v.x), abs(v.y))); }
      fn cone(v: vec2f) -> f32 { return 1. - smoothstep(0., 2., length(v)); }
      fn hard_cone(v: vec2f) -> f32 { return 1. - step(2., length(v)); }
      fn filled(v: vec2f) -> f32 { return 1.; }
      fn gaussian(v: vec2f) -> f32 {
        let d2 = dot(v, v);
        if (d2 > 4.) { return 0.; }
        return exp(-d2);
      }
      @fragment
      fn frag_main(vtx: SplatOut) -> @location(0) vec4f {
        if (vtx.color.a == 0.) { discard; }
        let d = vtx.color.a * ${kFuncNames[visu_func]}(vtx.uv);
        return vec4f(vtx.color.rgb * d, d);
      }
    `;
  }
  const vs_splats_render_module = render.device.createShaderModule({code: vs_splats_code});
  const fs_code = fs_splats_code(params.visu);
  const fs_splats_render_module = render.device.createShaderModule({code: fs_code});

  let pipeline_descriptor = {
    layout: 'auto',
    vertex: {
      module: vs_splats_render_module,
      entryPoint: 'vtx_main',
      buffers: [
        // Splats2D
        { arrayStride: 12 * FLOAT32_SIZE,
          stepMode: 'instance',
          attributes: [
            { shaderLocation: 0, offset: 0 * FLOAT32_SIZE, format: 'float32x4', },  // position
            { shaderLocation: 1, offset: 4 * FLOAT32_SIZE, format: 'float32x4', },  // cov
            { shaderLocation: 2, offset: 8 * FLOAT32_SIZE, format: 'uint32', },     // color
          ],
        },
      ],
    },
    fragment: {
      module: fs_splats_render_module,
      entryPoint: 'frag_main',
      targets: [{
        format: render.textureFormat,
        blend: {
          color: {srcFactor: 'one-minus-dst-alpha', dstFactor: 'one', operation: 'add'},
          alpha: {srcFactor: 'one-minus-dst-alpha', dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'none',
      // unclippedDepth: true,
    },
  };
  if (params.use_MSAA) {
    pipeline_descriptor.multisample = { count: 4 };
  }
  if (params.use_depth) {
    pipeline_descriptor.depthStencil = {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    };
  }
  render.splats_pipeline =
      render.device.createRenderPipeline(pipeline_descriptor);

  // create bind groups
  const STRIDE1 = 12 * 4;
  const STRIDE2 = 12 * 4;
  const STRIDE3 = 4;  // uint32 for insta
  const max_splats = render.splats_3D.size / STRIDE1;
  render.update_bind_groups = [];
  for (let splats = 0; splats < max_splats; ) {
    const batch_size = Math.min(256, Math.ceil((max_splats - splats) / 64)) * 64;
    const nb_splats = Math.min(batch_size, max_splats - splats);
//    console.log("splats:", splats, "num_splats:", nb_splats, "max splats:", max_splats);
    const update_bind_group = render.device.createBindGroup({
      layout: render.update_pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: render.uniforms_buffer, }, },
        { binding: 1, resource: { buffer: render.splats_3D, }, },  // need the whole buffer!
        { binding: 2, resource: { buffer: render.splats_2D,
                                  offset: splats * STRIDE2,
                                  size: nb_splats * STRIDE2 }, },
        { binding: 3, resource: { buffer: render.instances_idx,
                                  offset: splats * STRIDE3,
                                  size: nb_splats * STRIDE3 }, },
      ],
    });
    render.update_bind_groups.push([nb_splats, update_bind_group]);
    splats += nb_splats;
  }

/*  BINDING NOT NEEDED FOR NOW!
  render.splats_bind_group = render.device.createBindGroup({
    layout: render.splats_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: render.uniforms_buffer, }, },
    ],
  });
*/
}

function init_splats_3D(device) {
  const buffer = render.device.createBuffer({
    size: params.num_splats * 12 * FLOAT32_SIZE,
    usage: GPUBufferUsage.STORAGE,
    mappedAtCreation: true,
  });
  new Float32Array(buffer.getMappedRange()).set(params.splats);
  buffer.unmap();
// TODO(skal): we only need to keep the splats' positions, for SortDepth()
//  params.splats = undefined;
  return buffer;
}

function init_splats_2D(device) {
  const BUFFER_SIZE = params.num_splats * 12 * FLOAT32_SIZE;
  const splats = new Float32Array(new ArrayBuffer(BUFFER_SIZE));
  const buffer = render.device.createBuffer({
    size: BUFFER_SIZE,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
  });
  return buffer;
}

async function init_render(render) {
  // Create the data buffers and the binding groups
  render.splats_3D = init_splats_3D(render.device);
  render.splats_2D = init_splats_2D(render.device);

  // Create uniforms buffer
  render.uniforms_buffer = render.device.createBuffer({
    size: 40 * FLOAT32_SIZE,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  // work buffer for storing ordered instances idx
  render.instances_idx = render.device.createBuffer({
    size: params.num_splats * FLOAT32_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    mappedAtCreation: true,
  });
  render.instances = new Uint32Array(params.num_splats);
  for (let n = 0; n < params.num_splats; ++n) render.instances[n] = n;
  new Uint32Array(render.instances_idx.getMappedRange()).set(render.instances);
  render.instances_idx.unmap();

  // (fixed) index buffer
  render.index_buffer = render.device.createBuffer({
    size: 6 * 4,  // 1 quad (6 vtx) per splats
    usage: GPUBufferUsage.INDEX,
    mappedAtCreation: true,
  });
  const kQuadMap = [0, 1, 2, 2, 0, 3];
  new Uint32Array(render.index_buffer.getMappedRange()).set(kQuadMap);
  render.index_buffer.unmap();

  if (params.use_MSAA) {
    render.multisample_texture = render.device.createTexture({
      label: 'multisample',
      size: [canvas.width, canvas.height],
      sampleCount: 4,
      format: render.textureFormat,
      usage: GPUTextureUsage.RENDER_ATTACHMENT,
    });
  } else {
    render.multisample_texture = undefined;
  }
  if (params.use_depth) {
    render.depthTexture = render.device.createTexture({
      label: 'depth',
      size: [canvas.width, canvas.height],
      format: 'depth24plus',
      usage: GPUTextureUsage.RENDER_ATTACHMENT,
      sampleCount: (params.use_MSAA ? 4 : 1),
    });
  } else {
    render.depthTexture = undefined;
  }
  create_pipeline(render);
};

// END OF GPU PART
////////////////////////////////////////////////////////////////////////////////

function SigmaFromScaleRotation(s, [q0, q1, q2, q3]) {
  // quaternion to rotation matrix
  const N = 2. / (q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);  // for normalization
  let M = [
    1. - N * (q2 * q2 + q3 * q3),      N * (q1 * q2 + q0 * q3),      N * (q1 * q3 - q0 * q2),
         N * (q1 * q2 - q0 * q3), 1. - N * (q1 * q1 + q3 * q3),      N * (q2 * q3 + q0 * q1),
         N * (q1 * q3 + q0 * q2),      N * (q2 * q3 - q0 * q1), 1. - N * (q1 * q1 + q2 * q2),
  ];
  // + left-scaling
  for (let j = 0; j < 3; ++j) {
    for (let i = 0; i < 3; ++i) M[j * 3 + i] *= s[j];
  }
  // ... and covariance matrix Sigma
  let S = [];
  for (let j = 0; j < 3; ++j) {
    for (let i = 0; i < 3; ++i) {
      let s = 0.;
      for (let k = 0; k < 3; ++k) s += M[i + k * 3] * M[j + k * 3];
      S[i + j * 3] = 8. * params.haze * s;   // pre-scale by '8 * haze'
    }
  }
  return S;
}

////////////////////////////////////////////////////////////////////////////////

function RandRange(a, b) { return Math.random() * (b - a) + a; }

function create_synth_splats(num_splats) {
  const STRIDE = 12;
  const BUFFER_SIZE = num_splats * STRIDE * FLOAT32_SIZE;
  const splats = new Float32Array(new ArrayBuffer(BUFFER_SIZE));
  const splats_u = new Uint8Array(splats.buffer);   // view as uint8
  for (let i = 0; i < num_splats; ++i) {
    // Position
    let x, y, z;
    let sx, sy, sz;
    const xM = 1.;
    const sM = .01;
    if (params.model == 'cube') {
      const I = parseInt(Math.floor(i));
      const t = RandRange(-xM, xM);
      const u = (I & 1) ? -xM : xM;
      const v = (I & 2) ? -xM : xM;

      switch ((I >> 2) % 3) {
        case 0: [x, y, z] = [u, v, t]; [sx, sy, sz] = [sM, sM, 0.]; break;
        case 1: [x, y, z] = [u, t, v]; [sx, sy, sz] = [sM, 0., sM]; break;
        case 2: [x, y, z] = [t, u, v]; [sx, sy, sz] = [0., sM, sM]; break;
      }
    } else {
      [x, y, z] = [RandRange(-xM, xM), RandRange(-xM, xM), RandRange(-xM, xM)];
    }
    splats.set([x, y, z, 1.], i * STRIDE + 0);

    // Color
    let r, g, b, a = 1.;
    if (params.random_colors) {
      [r, g, b, a] = [RandRange(0., 255), RandRange(0., 255),
                      RandRange(0., 255), RandRange(0., 255)];
    } else {
      r = g = b = i;
      a = 255;
    }
    splats_u.set([r, g, b, a], 4 * (i * STRIDE + 10));

    // covariance (from matrix M = Scale * Rotation)
    if (params.model == 'cube') {
      splats.set([sx, 0., 0., sy, 0., sz], i * STRIDE + 4);
    } else {
      // rotation quaternion
      const q = [RandRange(-1.0, 1.), RandRange(-1.0, 1.),
                 RandRange(-1.0, 1.), RandRange(-1.0, 1.)];
      const s = [RandRange(-sM, sM), RandRange(-sM, sM), RandRange(-sM, sM)];
      const sigma = SigmaFromScaleRotation(s, q);
      splats.set([sigma[0], sigma[1], sigma[2],   // upper half only
                            sigma[4], sigma[5],
                                      sigma[8]], i * STRIDE + 4);
    }
    // TODO: SPH
  }
  params.target = [0., 0., 0.];
  params.radius = 2.;
  return [num_splats, splats];
}

////////////////////////////////////////////////////////////////////////////////
// .splat file-loading from URL

async function LoadURL(name) {
//  const url = new URL(name, "http://localhost:8000/");
  const url = new URL(name, "https://huggingface.co/cakewalk/splat-data/resolve/main/");
  const req = await fetch(url, { mode: "cors", credentials: "omit", });
  if (req.status != 200) Oops("Couldn't load URL [" + req.url + "]");
  console.log("Loaded", req.url);

  const bytes = await req.blob();
  const data = new Uint8Array(await bytes.arrayBuffer());
  const data_f = new Float32Array(data.buffer);  // float view
  const data_u = new Uint8Array(data.buffer);    // uint8 view
  console.log("Finished loading! bytes:" + data.length);

  const row_stride = (3 + 3 + 1 + 1);   // stride as float
  const row_size = row_stride * FLOAT32_SIZE;  // pos, color, packed scale, packed rotation
  let num_splats = data.length / row_size;
  const STRIDE = 12;
  const BUFFER_SIZE = num_splats * STRIDE * FLOAT32_SIZE;
  const splats = new Float32Array(num_splats * STRIDE);
  const splats_u = new Uint8Array(splats.buffer);  // view as uint8

  console.log("splat data: " + data.length + " bytes ( => " + num_splats + " splats)");

  let mins = [ Infinity, Infinity, Infinity];
  let maxs = [-Infinity,-Infinity,-Infinity];

  for (let i = 0; i < num_splats; ++i) {
    const off_f = i * row_stride;   // float-offset
    const xyz = data_f.slice(off_f + 0, off_f + 3);
    splats.set(xyz, i * STRIDE + 0);  // position
    splats[i * STRIDE + 3] = 1.;
    for (let k = 0; k < 3; ++k) {
      mins[k] = Math.min(mins[k], xyz[k]);
      maxs[k] = Math.max(maxs[k], xyz[k]);
    }

    splats_u.set(data_u.slice(4 * (off_f + 6), 4 * (off_f + 7)),
                 4 * (i * STRIDE + 10));  // color

    const s = data_f.slice(off_f + 3, off_f + 6);
    const q = new Float32Array(data_u.slice(4 * (off_f + 7), 4 * (off_f + 8)))
                .map((v) => v / 128. - 1.);
    const sigma = SigmaFromScaleRotation(s, q);
    splats.set([sigma[0], sigma[1], sigma[2],   // upper half only
                          sigma[4], sigma[5],
                                    sigma[8]], i * STRIDE + 4);  // sigma
  }
  return [num_splats, splats];
}

function center_model() {
  // normalize positions along major axis
  let mins = [ Infinity, Infinity, Infinity];
  let maxs = [-Infinity,-Infinity,-Infinity];
  const STRIDE = 12;
  for (let i = 0; i < params.num_splats; ++i) {
    let xyz = params.splats.slice(i * STRIDE + 0, i * STRIDE + 3);  // position
    for (let k = 0; k < 3; ++k) {
      mins[k] = Math.min(mins[k], xyz[k]);
      maxs[k] = Math.max(maxs[k], xyz[k]);
    }
  }
  let                           [min, diam] = [mins[0], maxs[0] - mins[0]];
  if (maxs[1] - mins[1] > diam) [min, diam] = [mins[1], maxs[1] - mins[1]];
  if (maxs[2] - mins[2] > diam) [min, diam] = [mins[2], maxs[2] - mins[2]];
//  params.target = [0.5 * (maxs[0] + mins[0]),
//                   0.5 * (maxs[1] + mins[1]),
//                   0.5 * (maxs[2] + mins[2])];
//  params.radius = diam;
  // diam = 2. / diam;
  diam = 1.;
  for (let i = 0; i < params.num_splats; ++i) {
    for (let k = 0; k < 3; ++k) {
      const mid = (maxs[k] + mins[k]) / 2.;
      params.splats[i * STRIDE + k] =
          (params.splats[i * STRIDE + k] - mid) * diam;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// utils for 3D

function normalize([x, y, z]) {
  const d = 1. / Math.hypot(x, y, z);
  return [x * d, y * d, z * d];
}
function cross([Ax, Ay, Az], [Bx, By, Bz]) {
  return [Ay * Bz - Az * By, Az * Bx - Ax * Bz, Ax * By - Ay * Bx];
}
function dot([Ax, Ay, Az], [Bx, By, Bz]) {
  return Ax * Bx + Ay * By + Az * Bz;
}
function LookAt([p_x, p_y, p_z],  // position
                [t_x, t_y, t_z],  // target
                [up_x, up_y, up_z]) {
  const [f_x, f_y, f_z] = normalize([p_x - t_x, p_y - t_y, p_z - t_z]);
  const [r_x, r_y, r_z] = normalize(cross([up_x, up_y, up_z], [f_x, f_y, f_z]));
  const [d_x, d_y, d_z] = cross([f_x, f_y, f_z], [r_x, r_y, r_z]);
  return new Float32Array([
      r_x, d_x, f_x, 0.,
      r_y, d_y, f_y, 0.,
      r_z, d_z, f_z, 0.,
      -dot([r_x, r_y, r_z], [p_x, p_y, p_z]),
      -dot([d_x, d_y, d_z], [p_x, p_y, p_z]),
      -dot([f_x, f_y, f_z], [p_x, p_y, p_z]), 1.]);
}
function Perspective(fx, fy, znear, zfar) {
  const A = zfar / (znear - zfar);
  const B = znear * A;
  return new Float32Array([
      -fx,  0., 0., 0.,
      0.,-fy,  0., 0.,
      0.,  0.,  A, -1.,
      0.,  0.,  B, 0.]);
}
function Multiply4(A, B) {  // 4x4 multiply
  let AB = [];
  for (let j = 0; j < 4; ++j) {
    for (let i = 0; i < 4; ++i) {
      AB[i + j * 4] = 0.;
      let s = 0.;
      for (let k = 0; k < 4; ++k) s += A[j * 4 + k] * B[i + k * 4];
      AB[i + j * 4] = s;
    }
  }
  return AB;
}

////////////////////////////////////////////////////////////////////////////////

function SetUniforms() {  // transmit uniforms
  const theta = params.theta * Math.PI / 180.;
  const phi = params.phi * Math.PI / 180.;
  params.view = LookAt(
      [ params.radius * Math.cos(theta) * Math.cos(phi) + params.target[0],
        params.radius * Math.sin(phi)                   + params.target[1],
        params.radius * Math.sin(theta) * Math.cos(phi) + params.target[2],
      ],
      params.target,
      [0., 1., 0.]);
  render.device.queue.writeBuffer(
      render.uniforms_buffer,  0 * FLOAT32_SIZE, params.view);

  const focal = 1. / Math.tan(params.fov * Math.PI / 360.);
  params.proj = Perspective(focal, focal * W / H, params.znear, params.zfar);
  render.device.queue.writeBuffer(
      render.uniforms_buffer, 16 * FLOAT32_SIZE, params.proj);

  const uniforms = new Float32Array([
      W, H, params.num_splats, params.haze,
      focal, focal * W / H, params.theta, params.phi]);
  render.device.queue.writeBuffer(
      render.uniforms_buffer, 32 * FLOAT32_SIZE, uniforms);
}

////////////////////////////////////////////////////////////////////////////////
// CPU-based sorting

async function SortDepth(render) {
  if (params.timing) console.time("SortDepth");
  // const mtx = Multiply4(param.proj, param.view);
  const mtx = params.view;
  const view = [mtx[2], mtx[6], mtx[10]];
  let max_depth = -Infinity, min_depth = Infinity;
  const STRIDE = 12;
  const idepths = new Int32Array(params.num_splats);
  for (let i = 0; i < params.num_splats; ++i) {
    const depth = 4096. * dot(params.splats.slice(STRIDE * i + 0, STRIDE * i + 3), view);
    if (max_depth < depth) max_depth = depth;
    if (min_depth > depth) min_depth = depth;
    idepths[i] = depth;
  }
  // Radix sort
  const SORT_MAX = 16384; // 256 * 256;
  const norm = (SORT_MAX - 1) / (max_depth - min_depth);
  const counts = new Uint32Array(SORT_MAX);
  for (let i = 0; i < params.num_splats; ++i) {
    const depth = idepths[i];
    const key = ((max_depth - depth) * norm) | 0;
    // const key = ((depth - min_depth) * norm) | 0;
    idepths[i] = key;
    ++counts[key];
  }
  let C = counts[0];
  counts[0] = 0;
  for (let i = 1; i < SORT_MAX; ++i) {
    const D = counts[i];
    counts[i] = C;
    C += D;
  }
  for (let i = 0; i < params.num_splats; ++i) {
    const pos = counts[idepths[i]]++;
    render.instances[pos] = i;
  }

// Debug:
//  const N = Math.max(10, Math.floor(params.num_splats * (params.tick % 100) / 100));
//  for (let i = N; i < params.num_splats; ++i) render.instances[i] = 0;

  // copy sorted instances indices
  render.device.queue.writeBuffer(render.instances_idx, 0, render.instances.buffer);

  if (params.timing) console.timeEnd("SortDepth");
}

////////////////////////////////////////////////////////////////////////////////

function frame() {
  performance.mark("webgpu start");

  ++params.tick;
  if (params.auto_rotate) params.theta -= 0.07;

  SetUniforms();

  if (params.depth_sort != 'none') {
    SortDepth(render);
  }

  if (params.timing) console.time("Render");

  const encoder = render.device.createCommandEncoder();

  for (const [nb_splats, bind_group] of render.update_bind_groups) {
    const compute_pass = encoder.beginComputePass();
    compute_pass.setPipeline(render.update_pipeline);
    compute_pass.setBindGroup(0, bind_group);
    compute_pass.dispatchWorkgroups(Math.ceil(nb_splats / 64), 64);
    compute_pass.end();
  }

  const pass_descriptor = {
      colorAttachments: [
        { view: undefined,
          resolveTarget: undefined,
          clearValue: {r:0., g:0., b:0., a:0.},
          loadOp: 'clear', storeOp: 'store', },
      ],
  };
  const canvas_view = ctx.getCurrentTexture().createView();
  canvas_view.label = 'CANVAS VIEW';
  if (params.use_MSAA) {
    const MSAA_view = render.multisample_texture.createView();
    MSAA_view.label = 'MULTISAMPLE';
    pass_descriptor.colorAttachments[0].view = MSAA_view;
    pass_descriptor.colorAttachments[0].resolveTarget = canvas_view;
  } else {
    pass_descriptor.colorAttachments[0].view = canvas_view;
  }
  if (params.use_depth) {
    pass_descriptor.depthStencilAttachment = {
        view: render.depthTexture.createView(),
        depthClearValue: 1.0,
        depthLoadOp: 'clear',
        depthStoreOp: 'store', };
  }
  const render_pass = encoder.beginRenderPass(pass_descriptor);
  render_pass.setPipeline(render.splats_pipeline);
//  NOT NEEDED FOR NOW! render_pass.setBindGroup(0, render.splats_bind_group);
  render_pass.setVertexBuffer(0, render.splats_2D);
  render_pass.setIndexBuffer(render.index_buffer, 'uint32');
  render_pass.drawIndexed(6, params.num_splats);
  render_pass.end();

  render.device.queue.submit([encoder.finish()]);

  if (params.timing) console.timeEnd("Render");
  performance.mark("webgpu end");

  performance.measure("webgpu", "webgpu start", "webgpu end");

  params.record_fps();
  if (params.req_id >= 0) params.req_id = requestAnimationFrame(frame);
}

////////////////////////////////////////////////////////////////////////////////

var render = {  /* device, uniforms, pipeline... */ };

async function init(do_init) {
  if (params.req_id != -1) {
    cancelAnimationFrame(params.req_id);
    params.req_id = -1;
  }
  if (do_init == true) {
    if (params.model == 'cube' || params.model == 'filled cube') {
      get_GUI_element('random_colors').enable();
      get_GUI_element('num_splats').enable();
      [params.num_splats, params.splats] =
          create_synth_splats(Math.min(100000, params.num_splats));
    } else {
      [params.num_splats, params.splats] = await LoadURL(params.model + ".splat");
      if (params.model == 'train') {
        params.phi = -16.;
        params.theta = -25.;
        params.radius = 1.8;
      } else if (params.model == 'nike') {
        center_model();
        params.radius = 1.8;
      } else if (params.model == 'plush') {
        center_model();
        params.radius = 1.8;
      }
      get_GUI_element('num_splats').disable();
      get_GUI_element('random_colors').disable();
    }
    params.info = params.num_splats + " splats";
    await init_render(render);
  }
  render.device || Oops("GPU device not initialized?!");
  await create_pipeline(render);
  params.tick = 0;
  params.last_t = Date.now();
  params.req_id = requestAnimationFrame(frame);    // start main loop

//  setInterval(() => { frame(); }, 1000);
}

</script>

</body>
</html>
