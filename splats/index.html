<!-- skal/ (pascal.massimino@gmail.com) 2023 -->
<!-- 3DGS renderer with WebGPU -->

<!DOCTYPE html>
<html>

<head>
<title>Gaussian Splat rendering with WebGPU</title>
<link rel="stylesheet" href="style.css">
</head>

<body onload="main();">
<div id='main-area'>
  <center>
    <b>one-file <a href='https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_low.pdf'>Gaussian Splat</a>
    rendering, using <a href='https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API'>WebGPU</a>
    (WIP)</b><br/>
    On <b>Chrome 113+</b>, you need to <a href='https://github.com/gpuweb/gpuweb/wiki/Implementation-Status'>enable</a>
    the <i>chrome://flags/#enable-webgpu-developer-features</i> !!<p>
    <div><canvas id="main-canvas"></canvas>
      <div id='info'><span id='fps' style='display:inline-block;width:90px;'></span></div>
      <form action="https://skal65535.github.io/">
        <input type="submit" value="skal 2023" id="skal-back"/>
      </form>
      <canvas id="progress-canvas" height='10px'></canvas>
    </div>
    <br/>
    <canvas id="side-canvas"></canvas>
  </center>
    This WebGPU implementation uses a compute-shader to extract the splats'
    parameters (position, axis, color) once for all.<br/>
    The vertex shader generates a quad as triangle-strip.<br/>
    The fragment shader has several 'visu' functions, other than the expected 'gaussian'.
    <i>Try 'cone', it looks good too!</i><br/>
    The exact depth-sort is done on CPU at regular intervals (it's a
    web-worker), while the GPU is doing an incremental insertion-sort [WIP!]
    to keep the splats approximately sorted while the CPU is working for real.<br/>
    <ul>
    KNOWN BUGS / LIMITATIONS:
    <li>z-sorting is imperfect, slow (see console with 'print timing'!), and produces flickering.
    The bottleneck is the writeBuffer() to send back the sorted id back to the GPU.</li>
    <li>No Spherical Harmonics for now.</li>
    </ul>
</div>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script>
"use strict";
const kVisus = {  // mapping from name to shader function
  'gaussian': 'gaussian', 'cone': 'cone',
  '(ellipsis)': 'ellipsis', '(dot)': 'small_dot', '(axis)': 'axis',
  '(hard cone)': 'hard_cone',
  '(square)': 'square', '(filled)': 'filled',
};

const kModels = {
  'nike': { file: 'nike.splat',  radius: 2.5, theta: -90., phi: 20., fov: 80., center:true, },
  'plush': { file: 'plush.splat', radius: 1.8, theta: -90., phi: 12., center:true, },
  'train': { file: 'train.splat', radius: 3.6, theta: -95., phi: -20., target: [0., 0., 0.], },
  'truck': { file: 'truck.splat', radius: 3.1, theta: 2.4, phi: 3., target: [0., 0., 0.], },
  'treehill': { file: 'treehill.splat', radius: 3.1, theta: 2.4, phi: 3., target: [0., 0., 0.], },
  'stump': { file: 'stump.splat', radius: 3.1, theta: 2.4, phi: 3., target: [0., 0., 0.], },
  'garden': { file: 'garden.splat', radius: 3.1, theta: 2.4, phi: 3., target: [0., 0., 0.], up:[1., 1., 1.], },
  'bicycle': { file: 'bicycle.splat', radius: 3.1, theta: 2.4, phi: 3., target: [0., 0., 0.], },
  '(counter)': { file: 'counter.splat', radius: 3.1, target: [0., 2., 0.], },
  '(toyroom)': { file: 'toyroom.splat', radius: 2.0, target: [0., 0., 0.], },
  '(drjohnson)': { file: 'drjohnson.splat', radius: 3.1, target: [0., 0., 0.], up: [-1., 0., 0.], },
  '(room)': { file: 'room.splat', radius: 3.1, target: [0., 2., 0.], },
  // synthetic models, for debug (no URL)
  '[cube]': { radius: 2.9, },
  '[galaxies]': {  radius: 2.1, },
};

const kSorts = {  // TODO(skal): simplify semantics!
  'GPU':      {cpu:false, gpu:true,  every:true,},
  'GPU only': {cpu:false, gpu:true,  every:false,},
  'CPU':      {cpu:true,  gpu:false, every:true,},
  'CPU full': {cpu:true,  gpu:false, every:false,},
  'none':     {cpu:false, gpu:false, every:false,},
};

////////////////////////////////////////////////////////////////////////////////

const args = new URLSearchParams(location.search);
function parse_arg_int(arg_value, default_value, min, max) {
  let v = args.has(arg_value) ? parseInt(args.get(arg_value)) : default_value;
  if (min != undefined) v = Math.max(v, min);
  if (max != undefined) v = Math.min(v, max);
  return v;
}
function parse_arg_str(arg_value, default_value) {
  return args.has(arg_value) ? args.get(arg_value) : default_value;
}
function parse_arg_bool(arg_value) { return (args.has(arg_value) == true); }


////////////////////////////////////////////////////////////////////////////////
// constants

const FLOAT32_SIZE = Float32Array.BYTES_PER_ELEMENT;
const UINT32_SIZE = Uint32Array.BYTES_PER_ELEMENT;

const STRIDE_POS  = 3;
const STRIDE_COV3 = 3;   // cov3d (upper half), packed as six f16
const STRIDE_COV2 = 2;   // axis 2x2, as four f16 packed as vec2u

// stride for .splat files, in bytes
const STRIDE_SPLAT = (3 + 3 + 1 + 1) * 4;

const side_canvas = document.querySelector("#side-canvas");
const canvas = document.querySelector("#main-canvas");
const ctx = canvas.getContext("webgpu");

////////////////////////////////////////////////////////////////////////////////

const params = {
  // Model
  model_name: parse_arg_str('model', 'truck'),

  // Camera
  fov: 90.,
  radius: 2.5,
  theta: -91.,
  phi: 30.0,
  target: [0., 0., 0.],
  up: [0., 1., 0.],
  znear: 0.1,
  zfar: 100.,
  auto_rotate: !parse_arg_bool("no-rotate"),
  mouse: {on:false, x:0., y:0.,
          zoom:false, l0: 0., l1:0. },

  // Visual
  visu: kVisus['gaussian'],
  use_MSAA: false,

  haze: 1.,
  dof: .0,  // fake Depth Of Field
  z_dof: 1.,

  sort_name: parse_arg_str('sort', 'CPU'),
  sort_sortsize: 32,
  sort_groupsize: 128,
  sort_every: parse_arg_int('every', 8),    // perform CPU-sort every xxx frame...
  sort_culled: !parse_arg_bool('no-cull'),  // cull splats during depth-sorting
  sort_wasm: parse_arg_bool('wasm'),
  sort_debug: parse_arg_bool('sdbg'),       // visualize sorted index and depths
  no_gui: parse_arg_bool('no-gui'),

  wsize: 256,        // maxComputeInvocationsPerWorkgroup,
  wsize_max: 65535,  // maxComputeWorkgroupsPerDimension
  max_buffer_size: 268435456,

  // debugging
  dbg: { random_colors: false, use_depth: false, progressive: true,
         use_localhost: parse_arg_bool('localhost'),
         draw_axis: parse_arg_bool('axis'),
         timing: false, synth_splats: 500,
         trace: parse_arg_int('trace', 0, 0, 3),
         skip_compute: parse_arg_bool('no-compute'), },
};

if (parse_arg_bool("dbg")) {
  params.auto_rotate = false;
  params.model_name = '[cube]';
  params.sort_name = 'GPU';
  params.visu = 'gaussian';
  params.haze = 1.0;
  params.dbg.synth_splats = 32;
  params.dbg.trace = 0;
  params.radius = 2.8;
  params.theta = 45.;
  params.phi = 30.;
}

////////////////////////////////////////////////////////////////////////////////
// GUI setup

const GUI_change = async () => { await init({}); }  // parameter changed
const GUI_reload = async () => { await init({model:true, sorting:true, buffers:true}); }    // (re)load a model

const GUI_init = () => {
  canvas.width  = parse_arg_int("w", innerWidth * .9);
  canvas.height = parse_arg_int("h", innerHeight * .8);

  if (params.no_gui) {
    render.gui = undefined;
    return;
  }
  render.gui = new lil.GUI({container: document.getElementById('#main-area'),
                            name: 'WebGPU Gaussian Splatting demo'});
  render.gui.add(params, 'model_name', Object.keys(kModels)).name('model').listen().onChange(GUI_reload);
  render.gui.add(params, 'visu', Object.keys(kVisus)).listen().onChange(GUI_change);
  render.gui.add(params, 'use_MSAA').name('multisampling').listen().onChange(() => init({textures:true}));
  const fun_folder = render.gui.addFolder('fun').close();
  fun_folder.add(params, 'haze', 1., 4., 0.05).name('haze effect (fun!)').listen().onChange(GUI_change);
  fun_folder.add(params, 'dof', 0., 1., 0.01).name('Depth of Field').listen().onChange(GUI_change);
  fun_folder.add(params, 'z_dof', 0., 1., 0.01).name('DoF distance').listen().onChange(GUI_change);
  const sort_folder = render.gui.addFolder('z-sort');
  sort_folder.add(params, 'sort_name', Object.keys(kSorts)).name('depth sorting algo').listen().onChange(() => init({sorting:true}));
  sort_folder.add(params, 'sort_culled').name('culled sort').listen().onChange(GUI_change);
  // sort_folder.add(params, 'sort_wasm').name('use WASM sort').listen().onChange(() => init({sorting:true}));
  sort_folder.add(params, 'sort_sortsize', [4, 8, 16, 32, 64, 128, 256]).name('sorting chunk size').listen().onChange(GUI_change);
  sort_folder.add(params, 'sort_groupsize', [4, 8, 16, 32, 64, 128, 256]).name('group size').listen().onChange(GUI_change);
  sort_folder.add(params, 'sort_every', 1, 64, 1).name('CPU sort every...').listen();
  sort_folder.add(params, 'sort_debug').name('visual debug').listen().onChange(() => init({sorting:true}));
  const cam_folder = render.gui.addFolder('camera').close();
  cam_folder.add(params, 'fov', 0., 180., 5.).listen();
  cam_folder.add(params, 'radius', 0.0001, 100., 0.01).listen();
  cam_folder.add(params, 'theta', 0., 360., 1.).listen();
  cam_folder.add(params, 'phi', -180., 180., 1.).listen();
  cam_folder.add(params, 'auto_rotate').name('auto rotate').listen();
  const dbg_folder = render.gui.addFolder('Debug').close();
  dbg_folder.add(params.dbg, 'synth_splats', 1, 100000, 1).name("# of synth splats").listen().onChange(GUI_reload);
  dbg_folder.add(params.dbg, 'random_colors').name('random colors').listen().onChange(GUI_reload);
  dbg_folder.add(params.dbg, 'progressive').name('progressive load').listen();
  dbg_folder.add(params.dbg, 'use_localhost').name('use localhost:8000').listen();
  dbg_folder.add(params.dbg, 'timing').name('print timing').listen();
  dbg_folder.add(params.dbg, 'trace', 0, 3, 1).name('trace level').listen();
  dbg_folder.add(params.dbg, 'use_depth').name('use depth (?!)').listen().onChange(() => init({textures:true}));
  dbg_folder.add(params.dbg, 'draw_axis').name('draw axis').listen().onChange(() => init({textures:true}));
  dbg_folder.add(params.dbg, 'skip_compute').name('skip compute (!?)').listen();
  dbg_folder.add(params, 'wsize', [4, 16, 64, 128, 256]).name('workgroup size').listen().onChange(GUI_change);
  dbg_folder.add(render, 'stored_splats').name('in-GPU splats').listen().disable();
  render.gui.add(render, 'txt_info').name('total splats').listen().disable();
  render.gui.add(render, 'txt_visible').name('visible').listen().disable();

  render.gui.domElement.style.top = '5%';
  render.gui.domElement.style.right = '3%';

  do_resize();
}

function GUI_get(name) {
  for (const c of render.gui.controllersRecursive()) {
    if (c.property == name) return c;
  }
  return undefined;
}

////////////////////////////////////////////////////////////////////////////////
// event handling

function ScaleXY(x, y) {
  const bounds = canvas.getBoundingClientRect();
  x = (x - bounds.left) / canvas.width;
  y = (y - bounds.top) / canvas.height;
  return [x, y];
}

function TouchToXY(event) {
  if (event.touches.length == 0) return [params.mouse.x, params.mouse.y];
  event.preventDefault();
  return ScaleXY(event.touches[0].clientX, event.touches[0].clientY);
}

function DownEvent(event) { if (event.target != canvas) return;
  if (event.touches && event.touches.length >= 2) {
    if (params.mouse.zoom == false) {
      params.mouse.on = false;
      params.mouse.zoom = true;
      const z_1 = ScaleXY(event.touches[0].clientX, event.touches[0].clientY);
      const z_2 = ScaleXY(event.touches[1].clientX, event.touches[1].clientY);
      params.mouse.l0 = Math.hypot(z_1.x - z_2.x, z_1.y - z_2.y);
      return;
    }
  }
  params.mouse.on = true;
}
function UpEvent(event) {
  if (params.mouse.zoom && event.touches.length >= 2) {
    const z_1 = ScaleXY(event.touches[0].clientX, event.touches[0].clientY);
    const z_2 = ScaleXY(event.touches[1].clientX, event.touches[1].clientY);
    params.mouse.l1 = Math.hypot(z_1.x - z_2.x, z_1.y - z_2.y);
    console.log(params.mouse.l0, params.mouse.l1);
  }
  params.mouse.on = false;
  params.mouse.zoom = false;
}

function MoveEvent([mouse_x, mouse_y]) {
  if (params.mouse.on) {
    params.phi   += (params.mouse.y - mouse_y) * 140.;
    params.theta += (params.mouse.x - mouse_x) * 140.;
  }
  params.mouse.x = mouse_x;
  params.mouse.y = mouse_y;
}

window.addEventListener('pointermove', (event) => {
  if (event.target != canvas) return;
//  event.preventDefault();
  MoveEvent(ScaleXY(event.clientX, event.clientY));
}, false);

window.addEventListener('pointerdown', (event) => DownEvent(event));
window.addEventListener('pointerup', (event) => UpEvent(event));
canvas.addEventListener('touchstart', (event) => DownEvent(event));
canvas.addEventListener('touchend', (event) => UpEvent(event));
canvas.addEventListener('touchmove', (event) => MoveEvent(TouchToXY(event)));
window.addEventListener('wheel', (event) => {
  if (event.target != canvas) return;
  event.preventDefault();
  params.radius *= (event.deltaY > 0.) ? 1.05 : 1. / 1.05;
}, { passive: false });

window.addEventListener("resize", (event) => {
  canvas.width = innerWidth * .9;
  canvas.height = innerHeight * .8;
  do_resize();
});

function do_resize() {
  const pcanvas = document.getElementById("progress-canvas")
  pcanvas.width = .93 * canvas.width;
  init_textures(render);
}

////////////////////////////////////////////////////////////////////////////////
////// WebGPU init //////

const trace = (level, ...args) => {
  if (params.dbg.trace > level) console.log(args.join(' '));
}

function Oops(e) {
  // document.body.innerHTML = `Oops! <pre>${e}</pre>`;
  side_canvas.style.display = 'inline-block';
  side_canvas.width = canvas.width * .8;
  const ctx = side_canvas.getContext('2d');
  ctx.fillStyle = '#f33';
  ctx.font = "bold 20px Arial";
  ctx.fillText('Oops!', 15, 30);
  ctx.font = "bold 12px Arial";
  ctx.fillText(e, 15, 55);
  throw Error(e);
}

const GPU_init = async () => {
  navigator.gpu || Oops("WebGPU not supported.");
  console.log("Navigator has GPU");

  const adapter = await navigator.gpu.requestAdapter();
  adapter || Oops("Couldn’t request WebGPU adapter.");
  console.log("WebGPU Adapter ok");

  render.device = await adapter.requestDevice();
  render.device || Oops("Couldn’t request WebGPU logical device.");
  console.log("WebGPU Device acquired.");
  for (const name of ['maxComputeInvocationsPerWorkgroup',
                      'maxComputeWorkgroupSizeX',
                      'maxComputeWorkgroupSizeY',
                      'maxComputeWorkgroupSizeZ',
                      'maxComputeWorkgroupStorageSize',
                      'maxComputeWorkgroupsPerDimension',
                      'maxStorageBufferBindingSize']) {
    console.log("  ->", name, ":", render.device.limits[name]);
  }
  params.wsize = render.device.limits['maxComputeInvocationsPerWorkgroup'];
  params.wsize_max = render.device.limits['maxComputeWorkgroupsPerDimension'];

  params.max_buffer_size = render.device.limits.maxBufferSize;
  params.max_binding_size = render.device.limits.maxStorageBufferBindingSize;

  function onDeviceError(event) {
    console.log("Something bad happened! Error type:", event.error.constructor.name);
    console.log("Error message:", event.error.message);
    if (render.device != undefined) {
      render.device.destroy();
      render.device = undefined;
    }
    stop_animation();
    Oops("Error caught while constructing the WebGPU device. See console.");
  }
  render.device.addEventListener('uncapturederror', onDeviceError);

  render.textureFormat = navigator.gpu.getPreferredCanvasFormat();
  ctx.configure({device: render.device,
                 format: render.textureFormat,
                 usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                 alphaMode: 'premultiplied', });
}

////////////////////////////////////////////////////////////////////////////////
// Pipelines & Shaders (the cool stuff!)

const uniforms_struct_code = `
    struct Uniforms {  // 43 * 4 bytes
      // 38 * 4
      view: mat4x4f,
      proj: mat4x4f,
      dim:  vec2f,   // screen dimension
      num_splats: f32,
      haze: f32,
      dof: f32,
      z_dof: f32,

      // 5 * 4 bytes
      focal: vec2f,
      znear: f32,
      zfar:  f32,
      sort_offset: u32,
    }
  `;

async function create_sort_pipeline(render) {
  if (!render.depth_sort.gpu) return;
  const sort_code = (ssize, gsize) => `
    ${uniforms_struct_code}

    @group(0) @binding(0) var<uniform> params: Uniforms;
    @group(0) @binding(1) var<storage, read> positions: array<array<f32, 3>>;
    @group(0) @binding(2) var<storage, read_write> sorted_list: array<u32>;

    fn depth(idx: u32) -> f32 {
      let s = positions[idx];
      var p = params.view * vec4f(s[0], s[1], s[2], 1.);
      return p.z;  // note: .proj would use 'z-inverted' convention
    }
    // each work unit sorts ${ssize} idx[] in isolation
    @compute @workgroup_size(1) fn main(
      @builtin(global_invocation_id) global_id : vec3u) {
      let id = global_id.y * ${gsize} + global_id.x;
      let s = id * ${ssize} + params.sort_offset;
      _ = params.view;
      for (var i : u32 = 1; i < ${ssize}; i += 1u) {
        if (s + i >= u32(params.num_splats)) { return; }
        let a = sorted_list[s + i];
        let za = depth(a);
        var j : u32 = i;
        while (j > 0) {
          let b = sorted_list[s + j - 1];
          if (za > depth(b)) {
            sorted_list[s + j] = b;
            j -= 1;
          } else {
            break;
          }
        }
        sorted_list[s + j] = a;
      }
    }
  `;
  render.sort_pipeline = render.device.createComputePipeline({
    layout: 'auto',
    compute: {
      module: render.device.createShaderModule(
        {code: sort_code(params.sort_sortsize, params.sort_groupsize)}),
      entryPoint: 'main',
    }
  });
  render.sort_bind_group = render.device.createBindGroup({
      layout: render.sort_pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: render.GPU.uniforms, }, },
        { binding: 1, resource: { buffer: render.GPU.positions, }, },
        { binding: 2, resource: { buffer: render.GPU.idx, }, },
      ],
    });
}

function create_update_pipeline(render) {
  const max_splats = render.max_splats;
  let dim_x = 1, dim_y = 0;
  do {
    ++dim_y;
    dim_x = Math.ceil(max_splats / params.wsize / dim_y);
  } while (dim_x > params.wsize_max);
  trace(-1, "Compute binding: wsize=", params.wsize, "dim_x=", dim_x, "dim_y=", dim_y);
  trace(-1, "  => total:", params.wsize * dim_x * dim_y, "for", max_splats, "splats");
  const s3d_size = STRIDE_COV3 * UINT32_SIZE * max_splats;
  const pos_size = STRIDE_POS * FLOAT32_SIZE * max_splats;
  const color_size =             UINT32_SIZE * max_splats;
  const s2d_size = STRIDE_COV2 * UINT32_SIZE * max_splats;
  const idx_size =               UINT32_SIZE * max_splats;
  trace(-1, " Total buffer mem:");
  trace(-1, "   Splats3D:", s3d_size);
  trace(-1, "   Splats2D:", s2d_size);
  trace(-1, "  positions:", pos_size);
  trace(-1, "     colors:", color_size);
  trace(-1, "        idx:", idx_size);
  trace(-1, "      total:", s3d_size + s2d_size + pos_size + color_size + idx_size);

  // COMPUTE pipeline, projecting the splats
  function compute_base_code() {
    return `
      ${uniforms_struct_code}

      @group(0) @binding(0) var<uniform> params: Uniforms;
      @group(0) @binding(1) var<storage, read> positions: array<array<f32, 3>>;
      @group(0) @binding(2) var<storage, read> sigmas: array<array<u32, 3>>;
      @group(0) @binding(3) var<storage, read_write> axis: array<vec2u>;
      @group(0) @binding(4) var<storage, read> sorted_idx: array<u32>;

      // Zwicker & Al: https://www.cs.umd.edu/~zwicker/publications/EWASplatting-TVCG02.pdf
      fn get_cov2d(vpos: vec4f, sigma: array<u32, 3>) -> vec3f {
        let focal = 0.5 * params.focal;
        let pz = 1. / vpos.z;
        // Jacobian (adjusted by a 'pz' factor)
        let J = mat4x4f(   // actually mat3x2f
          -focal.x,      0., focal.x * vpos.x * pz, 0.,
                0.,-focal.y, focal.y * vpos.y * pz, 0.,
                0.,      0.,                    0., 0.,
                0.,      0.,                    0., 0.,
        );
        // we'd need to extract mat2x3f from 'view' => T is actually mat3x3f
        let T = transpose(params.view) * J;

        // Vk is actually mat3x3f
        let s01 = unpack2x16float(sigma[0]);
        let s23 = unpack2x16float(sigma[1]);
        let s45 = unpack2x16float(sigma[2]);
        let Vk = mat4x4f(s01.x, s01.y, s23.x, 0.,
                         s01.y, s23.y, s45.x, 0.,
                         s23.x, s45.x, s45.y, 0.,
                            0.,    0.,    0., 0.,
        );
        var cov2d = transpose(T) * Vk * T;

        // low-pass filter: avoid degenerate cases of sub-pixel sizes
        // cov2d[0][0] += 1e-8; cov2d[1][1] += 1e-8;

        // only need the upper 2x2 matrix
        return vec3f(cov2d[0][0], cov2d[1][1], cov2d[0][1]);
      }

      // https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
      fn get_axis(vpos: vec4f, cov2d: vec3f) -> vec2u {
        let dist = 0.5 * (cov2d.x - cov2d.y);
        let trace = (cov2d.x + cov2d.y) * 0.5;
        let det = length(vec2f(dist, cov2d.z));
        let lambda1 = clamp(trace + det, 0., 16383.);
        let lambda2 = clamp(trace - det, 0., 16383.);
        let dof = 1. + params.dof * smoothstep(0., 1., abs(vpos.z - params.z_dof));
        let haze = params.haze * dof;
        let diag = haze * normalize(vec2f(cov2d.z, det - dist));
        let major = sqrt(lambda1) * diag;
        let minor = sqrt(lambda2) * vec2f(diag.y, -diag.x);
        return vec2u(pack2x16float(major), pack2x16float(minor));  // vec2f_to_axis
      }
      fn compute_axis(idx: u32) -> vec2u {
        let s = positions[idx];
        let vpos = params.view * vec4f(s[0], s[1], s[2], 1.);
        let position = params.proj * vpos;
        let clip = 1.1 * position.w;
        if (any(position.xyz > vec3f( clip, clip, clip)) ||
            any(position.xyz < vec3f(-clip, -clip,  0.))) {
          return vec2u(0);   // discard
        }
        let cov2d = get_cov2d(vpos, sigmas[idx]);  // mat2x2 = [x, z][z, y]
        return get_axis(position, cov2d);
      }
    `;
  }
  function compute_main_code(wsize, xsize, xysize, mapped_idx) {
    return `
      @compute @workgroup_size(${wsize})
      fn main(@builtin(global_invocation_id) global_id : vec3u) {
        let num_splats = u32(params.num_splats);
        var idx = global_id.z * ${xysize} + global_id.y * ${xsize} + global_id.x;
        if (idx >= num_splats) { return; }
        ${mapped_idx} = sorted_idx[idx];
        axis[idx] = compute_axis(idx);
      }
    `;
  };
  const base_code = compute_base_code();

  render.update_pipeline = render.device.createComputePipeline({
    layout: "auto",
    compute: {
      module: render.device.createShaderModule(
        {code: base_code +
               compute_main_code(params.wsize,
                                 dim_x * params.wsize,
                                 dim_y * dim_x * params.wsize,
                                 params.sort_culled ? "idx" : "_" /* wow!*/),
        },),
      entryPoint: "main",
    },
  });

  // create COMPUTE binding groups
  const update_bind_group = render.device.createBindGroup({
      layout: render.update_pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: render.GPU.uniforms, }, },
        { binding: 1, resource: { buffer: render.GPU.positions, }, },
        { binding: 2, resource: { buffer: render.GPU.sigmas, }, },
        { binding: 3, resource: { buffer: render.GPU.axis, }, },
        { binding: 4, resource: { buffer: render.GPU.idx, }, },
      ],
  });
  render.update_bindings = [dim_x, dim_y, update_bind_group];
}

function create_splats_pipeline(render) {
  // RENDER pipeline drawing the splats
  const SplatOut_struct_code = `
    struct SplatOut {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
        @location(1) @interpolate(flat) color:  vec4f,
    };
  `;

  function vs_splats_code() {
    return `
      ${uniforms_struct_code}
      ${SplatOut_struct_code}

      @group(0) @binding(0) var<uniform> params: Uniforms;
      @group(0) @binding(1) var<storage, read> positions: array<array<f32, 3>>;
      @group(0) @binding(2) var<storage, read> axis: array<vec2u>;
      @group(0) @binding(3) var<storage, read> colors: array<u32>;

      const kQuad = array<vec2f, 4>(  // quad [-2,2]x[-2,2]
        vec2f(  2., -2.), vec2f(  2.,  2.),
        vec2f( -2., -2.), vec2f( -2.,  2.),
      );
      @vertex fn vtx_main(@builtin(vertex_index) vtx_idx: u32,
                          @location(0) idx: u32,   // <- sorted idx
      ) -> SplatOut {
        var output : SplatOut;
        let major = unpack2x16float(axis[idx].x);
        let minor = unpack2x16float(axis[idx].y);
        // TODO(skal): if cov == 0 -> discard (cull)
        output.uv = kQuad[vtx_idx];
        let delta = output.uv.x * major + output.uv.y * minor;
        let s = positions[idx];
        let position = vec4f(s[0], s[1], s[2], 1.0);
        let vpos = params.proj * params.view * position;
        output.position = vpos + vec4f(delta, 0., 0.);
        output.color = unpack4x8unorm(colors[idx]);
        return output;
      }
  `};
  const visu_code = `
      fn ellipsis(v: vec2f) -> f32 { return smoothstep(.9, 1., length(v)) - step(1., length(v)); }
      fn small_dot(v: vec2f) -> f32 { return 1. - step(.1, length(v)); }
      fn square(v: vec2f) -> f32 { return smoothstep(1.90, 2.00, max(abs(v.x), abs(v.y))); }
      fn axis(v: vec2f) -> f32 { return 1. - smoothstep(0.00, .05, min(abs(v.x), abs(v.y))); }
      fn cone(v: vec2f) -> f32 { return 1. - smoothstep(0., 2., length(v)); }
      fn hard_cone(v: vec2f) -> f32 { return 1. - step(2., length(v)); }
      fn filled(v: vec2f) -> f32 { return 1.; }
      fn gaussian(v: vec2f) -> f32 {
        let d2 = dot(v, v);
        if (d2 > 4.) { return 0.; }
        return exp(-d2);
      }
  `;
  function fs_splats_code(visu_func) {
    return `
      ${SplatOut_struct_code}
      ${visu_code}
      @fragment fn frag_main(vtx: SplatOut) -> @location(0) vec4f {
        let color = vtx.color;
        let d = color.a * ${visu_func}(vtx.uv);
        return vec4f(color.rgb * d, d);
      }
    `;
  }
  const vs_splats_render_module = render.device.createShaderModule({ code: vs_splats_code() });
  const fs_code = fs_splats_code(kVisus[params.visu]);
  const fs_splats_render_module = render.device.createShaderModule({code: fs_code});

  let pipeline_descriptor = {
    layout: 'auto',
    vertex: {
      module: vs_splats_render_module,
      entryPoint: 'vtx_main',
      buffers: [
        { arrayStride: UINT32_SIZE,
          stepMode: 'instance',
          attributes: [ { shaderLocation: 0, offset: 0, format: 'uint32', }, ],
        },
      ],
    },
    fragment: {
      module: fs_splats_render_module,
      entryPoint: 'frag_main',
      targets: [{
        format: render.textureFormat,
        blend: {
          color: {srcFactor: 'one-minus-dst-alpha', dstFactor: 'one', operation: 'add'},
          alpha: {srcFactor: 'one-minus-dst-alpha', dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: {
      topology: 'triangle-strip',
      cullMode: 'none',
      // unclippedDepth: true,
    },
  };

  if (params.use_MSAA) {
    pipeline_descriptor.multisample = { count: 4 };
  }
  if (params.dbg.use_depth) {
    pipeline_descriptor.depthStencil = {
      depthWriteEnabled: true,
      depthCompare: 'less',
      format: 'depth24plus',
    };
  }
  render.splats_pipeline =
      render.device.createRenderPipeline(pipeline_descriptor);

  render.splats_bind_group = render.device.createBindGroup({
    layout: render.splats_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: render.GPU.uniforms, }, },
      { binding: 1, resource: { buffer: render.GPU.positions, }, },
      { binding: 2, resource: { buffer: render.GPU.axis, }, },
      { binding: 3, resource: { buffer: render.GPU.colors, }, },
    ],
  });
}

function create_axis_pipeline(render) {
  if (!params.dbg.draw_axis) return;

  // RENDER pipeline for axis
  const axis_code = `
      ${uniforms_struct_code}
      @group(0) @binding(0) var<uniform> params: Uniforms;
      struct TriOut { @builtin(position) position: vec4f,
                      @location(0) @interpolate(flat) color: u32, };
      const kAxis = array<vec3f, 12>(
        vec3f(1., 0., 0.), vec3f(.9, .1, .0), vec3f( .9,-.1, .0), vec3f(0.),  // x-axis
        vec3f(0., 1., 0.), vec3f(.0, .9, .1), vec3f( .0, .9,-.1), vec3f(0.),  // y-axis
        vec3f(0., 0., 1.), vec3f(.1, .0, .9), vec3f(-.1, .0, .9), vec3f(0.),  // z-axis
      );
      const kColor = array<u32, 3>(0xff0000ff, 0xff00ff00, 0xffff0000);  // ABGR
      @vertex fn vs_main(@builtin(vertex_index) vtx_idx: u32,
                         @builtin(instance_index) idx: u32,) -> TriOut {
        let v = vec4(kAxis[vtx_idx + 4 * idx], 1.);
        return TriOut(params.proj * params.view * v, kColor[idx]);
      }
      @fragment fn fs_main(f: TriOut) -> @location(0) vec4f {
        return unpack4x8unorm(f.color);
      }
  `;
  const axis_module = render.device.createShaderModule({code: axis_code});
  render.axis_pipeline = render.device.createRenderPipeline({
    layout: 'auto',
    vertex: { module: axis_module, entryPoint: 'vs_main', },
    fragment: { module: axis_module, entryPoint: 'fs_main', targets: [{ format: render.textureFormat, },], },
    primitive: { topology: 'triangle-strip', cullMode: 'none', },
    depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus', },
    multisample: { count: (params.use_MSAA ? 4 : 1), },
  });
  render.axis_bind_group = render.device.createBindGroup({
    layout: render.axis_pipeline.getBindGroupLayout(0),
    entries: [ { binding: 0, resource: { buffer: render.GPU.uniforms, }, }, ],
  });
}

function create_pipelines(render) {
  render.device || Oops("Can't create pipelines without a device!");
  create_sort_pipeline(render),
  create_update_pipeline(render),
  create_splats_pipeline(render),
  create_axis_pipeline(render),
  render.tick = 0;
  render.time_stamp = undefined;
  render.fps = 60.;
}

////////////////////////////////////////////////////////////////////////////////
// Create the data buffers

async function init_buffers(render) {
  trace(0, "Init buffers() => max_splats:", render.max_splats,
        ", num_splats:", render.num_splats);

  // Create the persistent GPU buffers that will be filled progressively
  render.GPU.sigmas = render.device.createBuffer({
    size: render.max_splats * STRIDE_COV3 * UINT32_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  render.GPU.positions = render.device.createBuffer({
    size: render.max_splats * STRIDE_POS * FLOAT32_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  render.GPU.colors = render.device.createBuffer({
    size: render.max_splats * 1 * UINT32_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  // create the cov2x2 buffer to communicate between COMPUTE and VERTEX shaders
  render.GPU.axis = render.device.createBuffer({
    size: render.max_splats * STRIDE_COV2 * UINT32_SIZE,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
  });

  // Create uniforms buffer
  render.GPU.uniforms = render.device.createBuffer({
    size: 44 * FLOAT32_SIZE,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  // shared CPU storage for sorted idx (persistent across sorting methods)
  render.CPU.idx = new Uint32Array(render.max_splats);
  for (let n = 0; n < render.max_splats; ++n) render.CPU.idx[n] = n;
  render.num_visible = render.max_splats;

  // work buffer on GPU, for storing ordered idx
  if (render.GPU.idx != undefined) render.GPU.idx.destroy();
  render.GPU.idx = render.device.createBuffer({
    size: render.max_splats * UINT32_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX |
           GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true,
  });
  new Uint32Array(render.GPU.idx.getMappedRange()).set(render.CPU.idx);
  render.GPU.idx.unmap();
}

async function init_textures(render) {
  if (render.multisample_texture != undefined) {
    render.multisample_texture.destroy();
    render.multisample_texture = undefined;
  }
  if (params.use_MSAA) {
    render.multisample_texture = render.device.createTexture({
      label: 'multisample',
      size: [canvas.width, canvas.height],
      sampleCount: 4,
      format: render.textureFormat,
      usage: GPUTextureUsage.RENDER_ATTACHMENT,
    });
  }
  if (render.depthTexture != undefined) {
    render.depthTexture.destroy();
    render.depthTexture = undefined;
  }
  if (params.dbg.use_depth || params.dbg.draw_axis) {
    render.depthTexture = render.device.createTexture({
      label: 'depth',
      size: [canvas.width, canvas.height],
      format: 'depth24plus',
      usage: GPUTextureUsage.RENDER_ATTACHMENT,
      sampleCount: (params.use_MSAA ? 4 : 1),
    });
  }
}

////////////////////////////////////////////////////////////////////////////////
// CPU-based sorting, using a web worker
//
//  It runs in parallel to the GPU incremental and incomplete per-frame sorting

function SortingThread(self) {
  let wasm_instance = null;  // WebAssembly module compiled
  let max_splats = 0;
  let positions = null;
  let idx = null;
  let fx = 1., fy = 1.;
  const STRIDE_POS = 3;
  const SORT_MAX = 65536; // 16384;

  const RadixSort = (keys, size, min_depth, max_depth) => {
    const norm = (SORT_MAX - 1) / (max_depth - min_depth);
    const counts = new Uint32Array(SORT_MAX);
    for (let i = 0; i < size; ++i) {
      const depth = keys[i];
      const key = ((max_depth - depth) * norm) | 0;
      // const key = ((depth - min_depth) * norm) | 0;
      keys[i] = key;
      ++counts[key];
    }

    let C = counts[0];
    counts[0] = 0;
    for (let i = 1; i < counts.length; ++i) {
      const D = counts[i];
      counts[i] = C;
      C += D;
    }
    return counts;
  }

  const SortDepthCulled = (view, proj, num_splats) => {
    const A = proj[10], B = proj[14];
    let max_depth = -10000000, min_depth = 10000000;
    const keys = new Int32Array(num_splats);
    const visible = new Uint32Array(num_splats);
    var num_visible = 0;
    for (let i = 0; i < num_splats; ++i) {
      const off = i * STRIDE_POS;
      const px = positions[off + 0];
      const py = positions[off + 1];
      const pz = positions[off + 2];
      const z = px * view[2] + py * view[6] + pz * view[10] + view[14];
      const x = px * view[0] + py * view[4] + pz * view[ 8] + view[12];
      const y = px * view[1] + py * view[5] + pz * view[ 9] + view[13];
      if (z > 0) continue;
      if (Math.abs(x) * fx > -z) continue;
      if (Math.abs(y) * fy > -z) continue;
      // TODO(skal): cull and use 1/z reverse-z
      const depth = 10000. * B * z; // should be: cst * (B * z - A);
      if (max_depth < depth) max_depth = depth;
      if (min_depth > depth) min_depth = depth;
      keys[num_visible] = depth;
      visible[num_visible] = i;
      ++num_visible;
    }
    const counts = RadixSort(keys, num_visible, min_depth, max_depth);
    for (let i = 0; i < num_visible; ++i) {
      const pos = counts[keys[i]]++;
      idx[pos] = visible[i];
    }
    return num_visible;
  };
  const SortDepth = (view, proj, num_splats) => {
    const zdir = new Float32Array([view[2], view[6], view[10], view[14]]);
    const A = proj[10], B = proj[14];
    let max_depth = -10000000, min_depth = 10000000;
    const keys = new Int32Array(num_splats);
    for (let i = 0; i < num_splats; ++i) {
      const px = positions[STRIDE_POS * i + 0];
      const py = positions[STRIDE_POS * i + 1];
      const pz = positions[STRIDE_POS * i + 2];
      const z = px * zdir[0] + py * zdir[1] + pz * zdir[2];
      const depth = 10000. * B * z; // should be: cst * (B * z - A);
      if (max_depth < depth) max_depth = depth;
      if (min_depth > depth) min_depth = depth;
      keys[i] = depth;
    }
    const counts = RadixSort(keys, num_splats, min_depth, max_depth);
    for (let i = 0; i < num_splats; ++i) {
      const pos = counts[keys[i]]++;
      idx[pos] = i;
    }
    return num_splats;
  };

  self.onmessage = (e) => {
    if (e.data.positions_buffer) {
      if (e.data.dbg) console.log("WRK: Received shared splats data:",
                                  e.data.max_splats);
      max_splats = e.data.max_splats;
      positions = new Float32Array(e.data.positions_buffer);
      idx       = new Uint32Array(e.data.idx_buffer);
    } else if (e.data.view) {
      if (e.data.dbg) console.log("WRK: Received sorting task:",
                                  e.data.num_splats, "/", max_splats);
      if (e.data.timing) console.time("SortDepth");
      fx = 0.96 * e.data.fx;
      fy = 0.96 * e.data.fy;
      let num_visible = new Float32Array([e.data.num_splats]);
      if (e.data.use_wasm && wasm_instance != undefined) {
        if (e.data.dbg) console.log("WRK: calling WASM sort.");
        if (e.data.do_cull) {
          wasm_instance.exports.sort_culled(e.data.view.buffer, e.data.proj.buffer,
              fx, fy, num_visible, positions.buffer, idx)
        } else {
          wasm_instance.exports.sort(e.data.view.buffer, e.data.proj.buffer,
              num_visible, positions.buffer, idx);
        }
      } else {
        num_visible[0] = e.data.do_cull ?
          SortDepthCulled(e.data.view, e.data.proj, e.data.num_splats) :
          SortDepth(e.data.view, e.data.proj, e.data.num_splats);
      }
      if (e.data.timing) console.timeEnd("SortDepth");
      if (e.data.dbg) console.log("WRK: Done sorting (", num_visible[0], "visible), sending back");
      self.postMessage({done:true, idx_buffer:idx.buffer, num_visible:num_visible[0]});
    } else if (e.data.wasm_module) {
      const imports = {
        'env': {
          'memoryBase': 0,
          'tableBase': 0,
          'memory': new WebAssembly.Memory({ initial: 256 }),
          emscripten_notify_memory_growth: () => { },
          emscripten_asm_const_int: console.log,
        },
        wasi_snapshot_preview1: {
          proc_exit: () => { },
        },
      };
      WebAssembly.instantiate(e.data.wasm_module, imports)
        .then(instance => wasm_instance = instance);
      console.log("WRK: Compiled the WASM module.");
    }
  };
}

function create_sort_worker(render) {
  const blob =
    new Blob(["(", SortingThread.toString(), ")(self)" ],
             { type: "application/javascript", });
  const sort_worker = new Worker(URL.createObjectURL(blob));
  if (params.sort_wasm) {
    fetch("sort.wasm").then(response => response.arrayBuffer())
                      .then(bytes => WebAssembly.compile(bytes))
                      .then(WasmModule => sort_worker.postMessage({wasm_module: WasmModule}));
  }

  sort_worker.onmessage = (e) => {
    trace(0, "SRT: Received back the sorted list (done:", e.data.done, ")");
    if (render.sort_discard || !render.sort_waiting) {
      trace(0, "SRT: ... but discarding the result.");
      render.sort_discard = false;
      render.sort_done = false;
    } else if (e.data.done) {
      render.CPU.idx = new Uint32Array(e.data.idx_buffer);
      render.num_visible = e.data.num_visible;
      render.sort_done = true;
    }
    render.sort_waiting = false;
  };
  return sort_worker;
}

function handle_sorting(render, encoder) {
  let sort_cpu = render.depth_sort.cpu;
  let sort_gpu = render.depth_sort.gpu;
  if (render.depth_sort.every) {
    if ((render.tick % params.sort_every) == 0) {
      sort_cpu = true;
      sort_gpu = false;
    }
  }
  if (sort_gpu) {
    if (render.stored_splats > 0) {
      const compute_pass = encoder.beginComputePass();
      compute_pass.setPipeline(render.sort_pipeline);
      compute_pass.setBindGroup(0, render.sort_bind_group);
      // the processing unit is #groupsize processing #sortsize values
      const groupsize = params.sort_sortsize * params.sort_groupsize;
      const batches = Math.ceil(render.stored_splats / groupsize);
      trace(0, "SRT: queueing a sorting pass on GPU,",
            batches, " batches of size",
            params.sort_groupsize, " x ", params.sort_sortsize,
            "=", groupsize * batches, "elements");
      compute_pass.dispatchWorkgroups(params.sort_groupsize, batches);
      compute_pass.end();

      if (params.sort_debug) {
        trace(2, "USING BUFFER");
        encoder.copyBufferToBuffer(
          render.GPU.idx, 0,
          render.GPU.mapped_idx, 0, render.stored_splats * UINT32_SIZE);
      }
    }
  } else if (sort_cpu) {
    // if ready, copy sorted instances indices
    if (render.sort_done) {
      trace(0, "SRT: sending sorted list of size", render.num_visible, "to GPU.");
      render.device.queue.writeBuffer(
          render.GPU.idx, 0, render.CPU.idx, 0, render.num_visible);
      render.sort_done = false;
    }
    // launch a new sorting job
    if (!render.sort_waiting) {
      trace(0, "SRT: sending list to sort to WRK.");
      // we don't need to resend the idx[] array, since the radix-sort
      // will fill it from scratch, and not incrementally
      render.sort_worker.postMessage(
        { num_splats:render.stored_splats,
          view:render.view, proj:render.proj,
          fx:render.fx, fy:render.fy, do_cull:params.sort_culled,
          timing:params.dbg.timing, dbg:(params.dbg.trace > 0),
          use_wasm:params.sort_wasm, });
      render.sort_waiting = true;
    }
  }
}

function DrawArray(mtx, data, height = canvas.height / 4) {
  data || Oops("Internal data is undefined.");
  const width = Math.min(data.length, canvas.width / 2);
  let max = 1.;
  for (let x = 0; x < width; ++x) {
    if (data[x] > max) max = data[x];
  }
  const scale = height / max;

  side_canvas.width = width;
  side_canvas.height = height;
  const ctx = side_canvas.getContext('2d');
  ctx.font = "bold 20px Arial";
  ctx.fillStyle = '#fff6';
  for (let x = 0; x < width; ++x) {
    const v = data[x] * scale;
    ctx.fillRect(x, height - v, 1, v);
  }
  ctx.fillStyle = '#fff';
  ctx.fillText("Indices", 20, 20);
  const zdir = [mtx[2], mtx[6], mtx[10], mtx[14]];
  let zmin = Infinity, zmax = -Infinity;
  for (let x = 0; x < width; ++x) {
    const pos = render.CPU.positions.slice(STRIDE_POS * data[x] + 0,
                                           STRIDE_POS * data[x] + 3);
    const z = pos[0] * zdir[0] + pos[1] * zdir[1] + pos[2] * zdir[2];
    if (z < zmin) zmin = z;
    if (z > zmax) zmax = z;
  }
  ctx.fillStyle = '#e3fa';
  const zscale = height / (zmax - zmin);
  for (let x = 0; x < width; ++x) {
    const pos = render.CPU.positions.slice(STRIDE_POS * data[x] + 0,
                                           STRIDE_POS * data[x] + 3);
    const z = zscale * (pos[0] * zdir[0] + pos[1] * zdir[1] + pos[2] * zdir[2] - zmin);
    ctx.fillRect(x, height - z, 1, z);
  }
  ctx.fillStyle = '#e3f';
  ctx.fillText("Depth keys", 20, 50);
}

async function debug_sort(render) {
  if (!render.depth_sort.gpu && !render.depth_sort.cpu) return;
  const mtx = render.view;
  if (render.depth_sort.gpu == false) {
    DrawArray(mtx, render.CPU.idx);
  } else {
    await render.GPU.mapped_idx.mapAsync(GPUMapMode.READ);
    const u32 = new Uint32Array(await render.GPU.mapped_idx.getMappedRange());
    DrawArray(mtx, u32);
    render.GPU.mapped_idx.unmap();
  }
}

async function init_sorting(render) {
  // set the sorting method
  render.depth_sort = kSorts[params.sort_name];

  // adapt the UI
  if (render.gui) {
    GUI_get('sort_groupsize').enable(render.depth_sort.gpu);
    GUI_get('sort_sortsize').enable(render.depth_sort.gpu);
    GUI_get('sort_debug').enable(render.depth_sort.gpu || render.depth_sort.cpu);
    GUI_get('sort_every').enable(render.depth_sort.every);
  }

  // debug: prepare mapping buffer to retrieve the on-GPU sorted-idx
  if (render.GPU.mapped_idx != undefined) {
    render.GPU.mapped_idx.destroy();
    render.GPU.mapped_idx = undefined;
  }
  if (params.sort_debug && (render.depth_sort.gpu || render.depth_sort.cpu)) {
    if (render.depth_sort.gpu) {
      render.GPU.mapped_idx = render.device.createBuffer({
        size: render.max_splats * UINT32_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });
    } else {  // CPU-sorting visual debug
    }
    side_canvas.style.display = 'inline-block';
  } else {
    side_canvas.style.display = 'none';
  }

  // launch the worker if needed
  if (render.sort_worker == undefined) {
    render.sort_worker = create_sort_worker(render);
    render.sort_discard = false;
  }
  // set-up the buffers shared with sort_worker
  trace(0, "SRT: Sending initial shared buffers (max_splats:", render.max_splats, ")");
  render.sort_worker.postMessage({ max_splats: render.max_splats,
                                   positions_buffer: render.CPU.positions.buffer,
                                   idx_buffer: render.CPU.idx.buffer,
                                   dbg:(params.dbg.trace > 0), });
}

// END OF GPU PART
////////////////////////////////////////////////////////////////////////////////

const as_f32 = new Float32Array(1);
const as_u32 = new Uint32Array(as_f32.buffer);
function f32To16(f32) {
  // https://www.corsix.org/content/converting-fp32-to-fp16
  as_f32[0] = f32;
  const u32 = as_u32[0];
  const m = (u32 >> 13) & 0x03ff;    // mantissa
  const e = (u32 >> 23) & 0x00ff;    // exponent
  const s = (u32 >> 16) & 0x8000;    // sign
  if (e >= 143 || e < 102) return s;  // NaN
  if (e <= 112) return ((m + 0x400) >> (113 - e)) | s;  // subnormals
  return s | ((e - 112) << 10) | m;
}

function f32To16x2(a, b) { return (f32To16(a) | (f32To16(b) << 16)) >>> 0; }
function PackSigmas(s) {   // pack six fp32's sigmas as three u32's
  return [f32To16x2(s[0], s[1]), f32To16x2(s[2], s[3]), f32To16x2(s[4], s[5])];
}

function SigmaFromScaleRotation(s, [q0, q1, q2, q3]) {
  // quaternion to rotation matrix
  const N = 2. / (q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);  // for normalization
  let M = [
    1. - N * (q2 * q2 + q3 * q3),      N * (q1 * q2 + q0 * q3),      N * (q1 * q3 - q0 * q2),
         N * (q1 * q2 - q0 * q3), 1. - N * (q1 * q1 + q3 * q3),      N * (q2 * q3 + q0 * q1),
         N * (q1 * q3 + q0 * q2),      N * (q2 * q3 - q0 * q1), 1. - N * (q1 * q1 + q2 * q2),
  ];
  // + left-scaling
  for (let j = 0; j < 3; ++j) {
    for (let i = 0; i < 3; ++i) M[j * 3 + i] *= s[j];
  }
  // ... and covariance matrix Sigma
  let S = [];
  for (let j = 0; j < 3; ++j) {
    for (let i = 0; i < 3; ++i) {
      let s = 0.;
      for (let k = 0; k < 3; ++k) s += M[i + k * 3] * M[j + k * 3];
      S[i + j * 3] = 8. * s;   // pre-scale by '8 * haze'
    }
  }
  // return upper half only
  return PackSigmas([S[0], S[1], S[2], S[4], S[5], S[8]]);
}

////////////////////////////////////////////////////////////////////////////////

function allocate_splats(max_splats) {
  render.CPU.positions = new Float32Array(max_splats * STRIDE_POS);
  render.CPU.colors    = new Uint8Array(max_splats * UINT32_SIZE);   // view as 4 x uint8
  render.CPU.sigmas    = new Uint32Array(max_splats * STRIDE_COV3);
  render.max_splats = max_splats;
  render.num_splats = 0;     // initial CPU storing
  render.stored_splats = 0;  // restart GPU transfer
  render.num_visible = 0;

  trace(0, "allocated buffers for splats with max_splats =" , max_splats);
}

function add_splats(num, src_u) {
  const from = render.num_splats;
  trace(1, "CPU: Added", num, "splats ( currently:", from, ", now:", from + num, ")");
  const src_f = new Float32Array(src_u.buffer);  // view as float
  const positions = render.CPU.positions;
  for (let i = from; i < from + num; ++i) {
    const off_f = (i - from) * (STRIDE_SPLAT / 4);   // float-offset
    render.CPU.positions.set(src_f.slice(off_f + 0, off_f + 3), STRIDE_POS * i);
    render.CPU.colors.set(src_u.slice(4 * (off_f + 6), 4 * (off_f + 7)), 4 * i);

    const s = src_f.slice(off_f + 3, off_f + 6);
    const q = new Float32Array(src_u.slice(4 * (off_f + 7), 4 * (off_f + 8)))
                .map((v) => v / 128. - 1.);
    render.CPU.sigmas.set(SigmaFromScaleRotation(s, q), i * STRIDE_COV3);
  }
  render.num_splats += num;
  render.sort_worker.postMessage({ max_splats: render.max_splats,
                                   positions_buffer: render.CPU.positions.buffer,
                                   idx_buffer:       render.CPU.idx.buffer,
                                   dbg:(params.dbg.trace > 0), });
}

////////////////////////////////////////////////////////////////////////////////

function RandRange(a, b) { return Math.random() * (b - a) + a; }

function create_synth_splats() {
  const num_splats = Math.max(10, Math.min(100000, params.dbg.synth_splats));
  allocate_splats(num_splats);
  for (let i = 0; i < num_splats; ++i) {
    let x, y, z, sx, sy, sz;
    const xM = 1., sM = .01;
    if (params.model_name == '[cube]') {
      const I = parseInt(Math.floor(i));
      const t = RandRange(-xM, xM);
      const u = (I & 1) ? -xM : xM;
      const v = (I & 2) ? -xM : xM;

      switch ((I >> 2) % 3) {
        case 0: [x, y, z] = [u, v, t]; [sx, sy, sz] = [sM, sM, 0.]; break;
        case 1: [x, y, z] = [u, t, v]; [sx, sy, sz] = [sM, 0., sM]; break;
        case 2: [x, y, z] = [t, u, v]; [sx, sy, sz] = [0., sM, sM]; break;
      }
    } else {
      [x, y, z] = [RandRange(-xM, xM), RandRange(-xM, xM), RandRange(-xM, xM)];
    }
    render.CPU.positions.set([x, y, z], STRIDE_POS * i);

    let rgba;
    if (params.dbg.random_colors) {
      rgba = [RandRange(0., 255), RandRange(0., 255), RandRange(0., 255), RandRange(0., 255)];
    } else {
      rgba = [i, i, i, 255];
    }
    render.CPU.colors.set(rgba, i * UINT32_SIZE);

    // covariance (from matrix M = Scale * Rotation)
    if (params.model_name == '[cube]') {
      render.CPU.sigmas.set(PackSigmas([sx, 0., 0., sy, 0., sz]), i * STRIDE_COV3);
    } else {
      // rotation quaternion
      const q = [RandRange(-1.0, 1.), RandRange(-1.0, 1.),
                 RandRange(-1.0, 1.), RandRange(-1.0, 1.)];
      const s = [RandRange(-sM, sM), RandRange(-sM, sM), RandRange(-sM, sM)];
      render.CPU.sigmas.set(SigmaFromScaleRotation(s, q), i * STRIDE_COV3);
    }
    // TODO: SPH
  }
  render.num_splats = num_splats;  // we already have everything
}

////////////////////////////////////////////////////////////////////////////////
// File-drop handling

const PreventDefault = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
document.addEventListener("dragenter", PreventDefault);
document.addEventListener("dragover", PreventDefault);
document.addEventListener("dragleave", PreventDefault);
document.addEventListener("drop", (event) => {
  PreventDefault(event);
  console.log("Reading file: " + event.dataTransfer.files[0]);
  DropFile(event.dataTransfer.files[0]);
});

function DropFile(file) {
  const fr = new FileReader();
  fr.onload = () => {
    render.sort_discard = true;  // cancel any pending sort
    const data = new Uint8Array(fr.result);
    const num_splats = Math.floor(data.length / STRIDE_SPLAT);
    allocate_splats(num_splats);
    add_splats(num_splats, data);
    init({buffers:true, sorting:true});
  };
  fr.readAsArrayBuffer(file);
}

////////////////////////////////////////////////////////////////////////////////
// .splat file-loading from URL

// Thanks Jake! https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
async function* StreamAsyncIterator(reader) {
  try {
    while (true) {
      const {done, value} = await reader.read();
      if (done) return;
      yield value;
    }
  } finally { reader.releaseLock(); }
}

async function CancelFetchURL() {
  if (render.reader) await render.reader.cancel();
  render.reader = undefined;
  render.loading = false;
  render.req = undefined;  // no longer needed
}

async function OpenURL(name) {
  const url = new URL(name, params.dbg.use_localhost ?
      "http://localhost:8000/" :
      "https://huggingface.co/cakewalk/splat-data/resolve/main/");
  const req = await fetch(url, { mode: "cors", credentials: "omit", });
  if (req.status != 200) Oops("Couldn't load URL [" + req.url + "]");
  const bytes_length = req.headers.get('content-length');
  render.req = req;

  // initiate URL transfer
  const max_splats = Math.floor(bytes_length / STRIDE_SPLAT);
  allocate_splats(max_splats);
  render.loading = true;
}

async function FetchURL() {
  !render.loading && Oops("Shouldn't be here.");
  !render.req && Oops("In-flight response not set.");
  render.reader && Oops("In-flight reader already launched.");

  console.log("Loading", render.req.url);
  let ok = false;
  if (!params.dbg.progressive) {
    // Fetch everything in one scoop
    const bytes = await render.req.blob();
    const data = new Uint8Array(await bytes.arrayBuffer());
    add_splats(render.max_splats, data);
    ok = true;
  } else {
    // Need to pass add_splats() a buffer aligned to multiples of STRIDE_SPLAT.
    // => we need a scratch buffer tmp[] to store input fragments.
    const tmp_size = 16 * STRIDE_SPLAT;
    const tmp = new Uint8Array(tmp_size);
    let tmp_stored = 0;  // tmp[] occupancy

    const pcanvas = document.getElementById("progress-canvas")
    const pctx = pcanvas.getContext("2d");
    pcanvas.style.display = 'inline-block';
    pctx.fillStyle = '#000';
    pctx.fillRect(0, 0, pcanvas.width, pcanvas.height);

    render.reader = render.req.body.getReader();
    const it = await StreamAsyncIterator(render.reader);
    let next_recenter = 1000;
    for await (const chunk of it) {
      const in_length = chunk.length;
      let in_pos = 0;
      // first we complete tmp[] buffer with chunk data
      let to_copy = tmp_size - tmp_stored;
      if (to_copy > in_length) to_copy = in_length;
      if (to_copy > 0) {
        tmp.set(chunk.slice(0, to_copy), tmp_stored);
        in_pos += to_copy;
        tmp_stored += to_copy;
      }
      // if tmp[] is full we convert to splats, otherwise input chunk
      // as been exhausted without filling tmp[].
      if (tmp_stored == tmp_size) {
        const new_splats = Math.floor(tmp_size / STRIDE_SPLAT);
        add_splats(new_splats, tmp);
        tmp_stored = 0;
      } else {
         (in_pos == in_length) || Oops("Inconsistent stream!");
        continue;   // not enough data in tmp[] or input chunk yet.
      }
      // Do we have convertible data left in chunk?
      if (in_pos < in_length) {
        const new_splats = Math.floor((in_length - in_pos) / STRIDE_SPLAT);
        const to_convert = new_splats * STRIDE_SPLAT;
        if (new_splats > 0) {
          add_splats(new_splats, chunk.slice(in_pos, in_pos + to_convert));
          in_pos += to_convert;
        }
      }
      // If we still have a little left-over at end, place it in tmp[]
      if (in_pos < in_length) {
        tmp.set(chunk.slice(in_pos, in_length));
        tmp_stored = in_length - in_pos;
      }
      // recenter from time to time
      if (render.model.center && render.num_splats > next_recenter) {
        center_model();
        next_recenter += 10000;
      }
      // display progress
      pctx.fillStyle = '#f318';
      pctx.fillRect(0, 0,
                    render.num_splats * pcanvas.width / render.max_splats,
                    pcanvas.height);
    }
    ok = (tmp_stored == 0);
    if (!ok) trace(0, "URL fetch was aborted.");

    render.reader = undefined;  // done with the reader, one way or the other.
    pcanvas.style.display = 'none';  // done
  }
  if (ok) {
    if (render.model.center) center_model();
    trace(-1, "Finished loading", render.num_splats, "splats.");
  }
  CancelFetchURL();  // we're done.
}

////////////////////////////////////////////////////////////////////////////////
// utils for 3D

function center_model() {   // center positions w/ box
  let mins = [ Infinity, Infinity, Infinity];
  let maxs = [-Infinity,-Infinity,-Infinity];
  for (let i = 0; i < render.num_splats; ++i) {
    let xyz = render.CPU.positions.slice(i * STRIDE_POS + 0, i * STRIDE_POS + 3);
    for (let k = 0; k < 3; ++k) {
      mins[k] = Math.min(mins[k], xyz[k]);
      maxs[k] = Math.max(maxs[k], xyz[k]);
    }
  }
  let                           [min, diam] = [mins[0], maxs[0] - mins[0]];
  if (maxs[1] - mins[1] > diam) [min, diam] = [mins[1], maxs[1] - mins[1]];
  if (maxs[2] - mins[2] > diam) [min, diam] = [mins[2], maxs[2] - mins[2]];
  params.target = [(maxs[0] + mins[0]) / 2,
                   (maxs[1] + mins[1]) / 2,
                   (maxs[2] + mins[2]) / 2,];
}

function normalize([x, y, z]) {
  const d = 1. / Math.hypot(x, y, z);
  return [x * d, y * d, z * d];
}
function cross([Ax, Ay, Az], [Bx, By, Bz]) {
  return [Ay * Bz - Az * By, Az * Bx - Ax * Bz, Ax * By - Ay * Bx];
}
function dot([Ax, Ay, Az], [Bx, By, Bz]) {
  return Ax * Bx + Ay * By + Az * Bz;
}
function look_at([p_x, p_y, p_z],  // position relative to target
                 [t_x, t_y, t_z],  // target
                 [up_x, up_y, up_z]) {
  const [f_x, f_y, f_z] = normalize([p_x, p_y, p_z]);
  const [r_x, r_y, r_z] = normalize(cross([up_x, up_y, up_z], [f_x, f_y, f_z]));
  const [d_x, d_y, d_z] = cross([f_x, f_y, f_z], [r_x, r_y, r_z]);
  p_x += t_x;
  p_y += t_y;
  p_z += t_z;
  return new Float32Array([
      r_x, d_x, f_x, 0.,
      r_y, d_y, f_y, 0.,
      r_z, d_z, f_z, 0.,
      -dot([r_x, r_y, r_z], [p_x, p_y, p_z]),
      -dot([d_x, d_y, d_z], [p_x, p_y, p_z]),
      -dot([f_x, f_y, f_z], [p_x, p_y, p_z]), 1.]);
}
function perspective(fx, fy, znear, zfar) {
  const A = znear / (zfar - znear);
  const B = zfar * A;
  return new Float32Array([
     -fx,  0., 0.,  0.,
      0., -fy, 0.,  0.,
      0.,  0.,  A, -1.,
      0.,  0.,  B,  0.]);
}

function compute_frame_params() {
  const aspect = canvas.width / canvas.height;
  render.fx = 1. / Math.tan(params.fov * Math.PI / 360.);
  render.fy = aspect * render.fx;
  render.proj = perspective(render.fx, render.fy, params.znear, params.zfar);
  const theta = params.theta * Math.PI / 180.;
  const phi = params.phi * Math.PI / 180.;
  render.view = look_at(
      [ params.radius * Math.cos(theta) * Math.cos(phi),
        params.radius *                   Math.sin(phi),
        params.radius * Math.sin(theta) * Math.cos(phi), ],
      params.target, params.up);
}

////////////////////////////////////////////////////////////////////////////////
// CPU -> GPU transfer

function transmit_uniforms() {
  render.device.queue.writeBuffer(render.GPU.uniforms,  0 * FLOAT32_SIZE, render.view);
  render.device.queue.writeBuffer(render.GPU.uniforms, 16 * FLOAT32_SIZE, render.proj);

  render.device.queue.writeBuffer(
    render.GPU.uniforms, 32 * FLOAT32_SIZE,
      new Float32Array([ canvas.width, canvas.height,
                         render.num_visible, params.haze,
                         params.dof, params.z_dof,
                         render.fx, render.fy,
                         params.znear, params.zfar, ]));

  const sort_offset = (render.tick % 2) * (params.sort_sortsize / 2);
  render.device.queue.writeBuffer(
      render.GPU.uniforms, 42 * FLOAT32_SIZE, new Uint32Array([ sort_offset ]));
}

function transmit_splats() {
  if (render.stored_splats < render.num_splats) {
    const off = render.stored_splats;
    const nb = render.num_splats - render.stored_splats;
    trace(0, "GPU: Sending", nb, "new splats");
    render.device.queue.writeBuffer(
        render.GPU.sigmas, off * STRIDE_COV3 * FLOAT32_SIZE,  // <- number of *bytes*
        render.CPU.sigmas, off * STRIDE_COV3,  // <- number of *elements*
        nb * STRIDE_COV3);
    render.device.queue.writeBuffer(
        render.GPU.colors, off * UINT32_SIZE,
        render.CPU.colors, off * UINT32_SIZE,
        nb * UINT32_SIZE);
    render.device.queue.writeBuffer(
        render.GPU.positions, off * STRIDE_POS * FLOAT32_SIZE,
        render.CPU.positions, off * STRIDE_POS,
        nb * STRIDE_POS);
    render.stored_splats = render.num_splats;
    render.num_visible = render.num_splats;
    if (render.stored_splats == render.max_splats) {
      trace(0, "Done transfering to GPU.");
      // get rid of unneeded buffers now but keep CPU.positions[] and CPU.idx[] for sorting
      render.CPU.sigmas = null;
      render.CPU.colors = null;
    }
  }
  trace(2, "STATE:", render.num_splats, "on CPU,", render.stored_splats, "on GPU");
}

////////////////////////////////////////////////////////////////////////////////
// Animation loop

async function frame() {
  const time_stamp = performance.now();
  if (render.time_stamp) {
    const delta_t = time_stamp - render.time_stamp;
    if (delta_t > 1.) {
      const new_fps = 1000. / delta_t;
      render.fps = Math.round(render.fps * 0.8 + new_fps * 0.2);
    }
    document.getElementById("fps").innerText = render.fps.toFixed(1) + " fps";
    render.txt_info = render.max_splats;
    render.txt_visible = render.num_visible;
  }
  render.time_stamp = time_stamp;

  performance.mark("webgpu start");

  compute_frame_params();

  transmit_uniforms();
  transmit_splats();

  const encoder = render.device.createCommandEncoder();

  handle_sorting(render, encoder);

  if (params.dbg.timing) console.time("GPU");

  if (render.tick > 0. && !params.dbg.skip_compute) {
    const [dim_x, dim_y, bind_group] = render.update_bindings;
    const compute_pass = encoder.beginComputePass();
    compute_pass.setPipeline(render.update_pipeline);
    compute_pass.setBindGroup(0, bind_group);
    compute_pass.dispatchWorkgroups(dim_x, dim_y);
    compute_pass.end();
  }

  const pass_descriptor = {
      colorAttachments: [
        { view: undefined,
          resolveTarget: undefined,
          clearValue: {r:0., g:0., b:0., a:0.},
          loadOp: 'clear', storeOp: 'store', },
      ],
  };
  const canvas_view = ctx.getCurrentTexture().createView({label: 'CANVAS'});
  if (params.use_MSAA) {
    const MSAA_view = render.multisample_texture.createView({label: 'MULTISAMPLE'});
    pass_descriptor.colorAttachments[0].view = MSAA_view;
    pass_descriptor.colorAttachments[0].resolveTarget = canvas_view;
  } else {
    pass_descriptor.colorAttachments[0].view = canvas_view;
  }
  if (params.dbg.use_depth) {
    pass_descriptor.depthStencilAttachment = {
        view: render.depthTexture.createView(),
        depthClearValue: 1.0,
        depthLoadOp: 'clear', depthStoreOp: 'store', };
  }
  if (render.num_splats > 0) {
    const render_pass = encoder.beginRenderPass(pass_descriptor);
    render_pass.setPipeline(render.splats_pipeline);
    render_pass.setBindGroup(0, render.splats_bind_group);
    render_pass.setVertexBuffer(0, render.GPU.idx,
                                0, render.num_visible * UINT32_SIZE);
    render_pass.draw(4, render.num_visible);
    render_pass.end();
  }

  if (params.dbg.draw_axis) {
    const axis_pass_descriptor = {
      colorAttachments: [
        { view: pass_descriptor.colorAttachments[0].view,
          resolveTarget: pass_descriptor.colorAttachments[0].resolveTarget,
          loadOp: 'load', storeOp: 'store', },
      ],
      depthStencilAttachment: {
        view: render.depthTexture.createView(),
        depthClearValue: 1.0, depthLoadOp: 'clear', depthStoreOp: 'store', },
    };
    const render_pass = encoder.beginRenderPass(axis_pass_descriptor);
    render_pass.setPipeline(render.axis_pipeline);
    render_pass.setBindGroup(0, render.axis_bind_group);
    render_pass.draw(4, 3);
    render_pass.end();
  }

  render.device.queue.submit([encoder.finish()]);

  if (params.dbg.timing) console.timeEnd("GPU");
  performance.mark("webgpu end");

  performance.measure("webgpu", "webgpu start", "webgpu end");

  if (params.sort_debug) await debug_sort(render);

  if (params.auto_rotate) params.theta -= 0.07;
  ++render.tick;
  render.loop_id = requestAnimationFrame(frame);
}

function stop_animation() {
  if (render.loop_id != undefined) {
    cancelAnimationFrame(render.loop_id);
    render.loop_id = undefined;
  }
}

////////////////////////////////////////////////////////////////////////////////

var render = {  /* Run-time data: device, uniforms, pipeline... */
  device: undefined,
  textureFormat: undefined,

  model: undefined,  // one of kModels[]
  max_splats: 500,   // final number of splats (once fetch is over)
  num_splats: 500,   // number of splats available on CPU for display
  stored_splats: 0,  // number of splats transfered to GPU so far
  num_visible: 0,    // visible after depth-sorting
  GPU: {   // data sent to GPU
    sigmas:    null,   // vec4u  packed f16s
    axis:      null,   // vec2u  packed f16s
    positions: null,   // vec3f
    colors:    null,   // u32
    idx:       null,   // sorted idx
    mapped_idx:null,   // copy-and-mapped idx, for display
    uniforms:  null,
  },
  CPU: {   // data hosted in GPU
    sigmas:    null,   // vec4u
    positions: null,   // vec3f
    colors:    null,   // u8x4
    idx:       null,   // u32 sorted idx
  },

  depth_sort: null,    // one of kSorts[]
  sort_worker: null,   // worker for depth-sorting
  sort_done:    false,
  sort_discard: false,
  sort_waiting: false,

  // per-frame params
  view: undefined,
  proj: undefined,
  fx: undefined,
  fy: undefined,

  // side info
  loading: false,   // in-flight request?
  req: undefined,   // the open request
  reader: undefined,
  fps: 60.,
  time_stamp: undefined,
  txt_info: "",
  txt_visible: "",
  loop_id: undefined,  // id for animation loop
  tick: 0.,

  gui: undefined,
};

async function set_model(model_name) {
  const model = kModels[model_name] || {file: model_name};
  if (render.sort_worker) {
    render.sort_discard = true;
  }
  render.model = model;
  render.max_splats = 0;

  CancelFetchURL();
  if (render.gui) {
    const with_synth = (model.file == undefined);
    GUI_get('synth_splats').enable(with_synth);
    GUI_get('random_colors').enable(with_synth);
  }
  if (model.file == undefined) {
    await create_synth_splats();
  } else {
    await OpenURL(model.file);
  }
  // set camera params if needed
  params.fov    = model.fov    || params.fov;
  params.radius = model.radius || params.radius;
  params.theta  = model.theta  || params.theta;
  params.phi    = model.phi    || params.phi;
  params.target = model.target || [0., 0., 0.];
  params.up     = model.up     || [0., 1., 0.];

  render.info = render.max_splats + " splats";
}

async function init(what) {
  render.device || Oops("Initialization failed. Is WebGPU supported and " +
                        "<a href='https://github.com/gpuweb/gpuweb/wiki/Implementation-Status'>enabled</a>?");
  stop_animation();

  if (what.model) {
    await set_model(params.model_name);
  }
  if (what.buffers) {
    await init_buffers(render);
  }
  if (what.textures) {
    await init_textures(render);
  }
  if (what.sorting) {
    await init_sorting(render);
  }
  create_pipelines(render);

  frame();    // start animation loop

  if (render.loading) await FetchURL();  // start loading splats
}

async function main() {
  try {
    GUI_init();
    await GPU_init();
    await GUI_reload();
  } catch(e) { Oops(e); }
}

</script>

</body>
</html>
