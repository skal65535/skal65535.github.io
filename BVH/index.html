<!-- Bounding Volume Hierarchy -->

<!DOCTYPE html>
<html>

<head>
<title>BVH</title>
<link rel="stylesheet" href="../splats/style.css">
</head>

<body onload="main();">
<div id='main-area'>
  <center>
    <b>BVH</b><br/>
    <div><canvas id="main-canvas"'></canvas></div>
    <form action="https://skal65535.github.io/">
      <input type="submit" value="skal 2025" id="skal-back"/>
    </form>
    <br/>
  </center>
    <br/>
</div>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script src="../common/args.js"></script>
<script src="../common/matrix.js"></script>
<script src="../common/utils.js"></script>
<script src="./bunny.js"></script>
<script>
"use strict";

////////////////////////////////////////////////////////////////////////////////

const trace = (level, ...args) => {
  if (params.dbg.trace > level) console.log(args.join(' '));
}

////////////////////////////////////////////////////////////////////////////////
// constants

const canvas = document.querySelector("#main-canvas");
const ctx = canvas.getContext("webgpu");

////////////////////////////////////////////////////////////////////////////////
// Params

const params = {
  method: parse_arg('method', 0),   // BVH method: 0 = triangle list, 1 = BVH
  tris: null,  // triangles struct, as UInt32Array
  vtx: null,  // vertex, as vec3f

  wsize: 256,            // maxComputeInvocationsPerWorkgroup,
  wsize_max: 65535,      // maxComputeWorkgroupsPerDimension
  max_buffer_size: 268435456,

  gui: null,

  // Camera / Visu
  cam: {
    fov: 90.,
    radius: 1.5,
    theta: 0.,
    phi: 30.0,
    znear: 0.1,
    zfar: 100.,
    auto_rotate: !parse_arg_bool("no-rotate"),
  },
  mouse: {on:false, x:0., y:0.},

  // debugging
  dbg: { timing: parse_arg_bool('timing'),
         trace: parse_arg('trace', 0, 0, 3),
       },
  no_gui: parse_arg_bool('no-gui'),
};

if (parse_arg_bool("dbg")) {
  params.dbg.trace = 0;
  params.dbg.timing = false;
}

////////////////////////////////////////////////////////////////////////////////
// GUI setup

const GUI_change = async () => { await init(); }  // parameter changed

const GUI_init = () => {
  canvas.width  = parse_arg("w", innerWidth * .9);
  canvas.height = parse_arg("h", innerHeight * .8);

  if (params.no_gui) {
    params.gui = undefined;
    return;
  }
  params.gui = new lil.GUI({container: document.getElementById('#main-area'), name: 'BVH'});
  params.gui.add(params, 'method', {'none': 0, 'BVH': 1}).listen().onChange(GUI_change);
  const cam_folder = params.gui.addFolder('camera / visu').close();
  cam_folder.add(params.cam, 'fov', 0., 180., 5.).listen();
  cam_folder.add(params.cam, 'radius', 0.0001, 100., 0.01).listen();
  cam_folder.add(params.cam, 'theta', 0., 360., 1.).listen();
  cam_folder.add(params.cam, 'phi', -180., 180., 1.).listen();
  cam_folder.add(params.cam, 'auto_rotate').name('auto rotate').listen();
  const dbg_folder = params.gui.addFolder('Debug').close();
  dbg_folder.add(params.dbg, 'timing').name('print timing').listen();
  dbg_folder.add(params.dbg, 'trace', 0, 3, 1).name('trace level').listen();
  params.gui.add(render, 'txt_info').name('fps').listen().disable();

  params.gui.domElement.style.top = '5%';
  params.gui.domElement.style.right = '3%';
}

////////////////////////////////////////////////////////////////////////////////
// event handling

window.addEventListener('pointermove', (event) => {
  if (event.target != canvas) return;
  event.preventDefault();
  const bounds = canvas.getBoundingClientRect();
  const mouse_x = (event.clientX - bounds.left) / canvas.width;
  const mouse_y = (event.clientY -  bounds.top) / canvas.height;
  if (params.mouse.on) {
    params.cam.phi   -= (params.mouse.y - mouse_y) * 140.;
    params.cam.theta += (params.mouse.x - mouse_x) * 140.;
  }
  params.mouse.x = mouse_x;
  params.mouse.y = mouse_y;
}, false);
window.addEventListener('pointerdown', (event) => {
  if (event.target == canvas) params.mouse.on = true;
});
window.addEventListener('pointerup', (event) => {
  params.mouse.on = false;
});
window.addEventListener('wheel', (event) => {
  if (event.target != canvas) return;
  event.preventDefault();
  params.cam.radius *= (event.deltaY > 0.) ? 1.05 : 1. / 1.05;
}, { passive: false });

window.addEventListener("resize", (e) => {
  canvas.width  = innerWidth  * .9;
  canvas.height = innerHeight * .8;
  do_resize();
});

function do_resize() {
  init_buffers(render);
}

////////////////////////////////////////////////////////////////////////////////
////// WebGPU init //////

function Oops(e) {
  document.body.innerHTML = `Oops! <pre>${e}</pre>`;
  throw Error(e);
}

const GPU_init = async () => {
  navigator.gpu || Oops("WebGPU not supported.");
  console.log("Navigator has GPU");

  const adapter = await navigator.gpu.requestAdapter();
  adapter || Oops("Couldn’t request WebGPU adapter.");
  console.log("WebGPU Adapter ok");

  render.device = await adapter.requestDevice();
  render.device || Oops("Couldn’t request WebGPU logical device.");
  console.log("WebGPU Device acquired.");
  for (const name of ['maxComputeInvocationsPerWorkgroup',
                      'maxComputeWorkgroupSizeX',
                      'maxComputeWorkgroupSizeY',
                      'maxComputeWorkgroupSizeZ',
                      'maxComputeWorkgroupStorageSize',
                      'maxComputeWorkgroupsPerDimension',
                      'maxStorageBufferBindingSize']) {
    console.log("  ->", name, ":", render.device.limits[name]);
  }
  params.wsize = render.device.limits['maxComputeInvocationsPerWorkgroup'];
  params.wsize_max = render.device.limits['maxComputeWorkgroupsPerDimension'];

  params.max_buffer_size = render.device.limits.maxBufferSize;
  params.max_binding_size = render.device.limits.maxStorageBufferBindingSize;

  function onDeviceError(event) {
    console.log("Something bad happened! Error type:", event.error.constructor.name);
    console.log("Error message:", event.error.message);
    if (render.device != undefined) {
      render.device.destroy();
      render.device = undefined;
    }
    stop_animation();
    Oops("Error caught while constructing the WebGPU device. See console.");
  }
  render.device.addEventListener('uncapturederror', onDeviceError);

  render.textureFormat = navigator.gpu.getPreferredCanvasFormat();
  ctx.configure({device: render.device,
                 format: render.textureFormat,
                 usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                 alphaMode: 'premultiplied', });
}

////////////////////////////////////////////////////////////////////////////////
// Pipelines & Shaders (the cool stuff!)

const visu_uniforms_struct_code = `
    struct Uniforms {
      view: mat4x4f,
      proj: mat4x4f,
      nb_tris:     f32,   // 32 * 4
      nb_vtx:      f32,   // 33
      width:       f32,   // 34
      aspect:      f32,   // 35
      fxy:         vec2f, // 36

      light:       vec4f, // 40
      // 44
    }
  `;

const common_code = `
    fn Hash1f(p: u32) -> f32 {
      var P = (p << 13) ^ p;
      P = P * (P * P * 15731 + 789221) + 1376312589;
      return bitcast<f32>((P >> 9) | 0x3f800000) - 1.;
    }
    fn Hash3f(p: u32) -> vec3f {
      return vec3f(Hash1f(p), Hash1f(p + 1423), Hash1f(p + 124453));
    }
    fn get_vtx(face_id: u32, vtx_id: u32) -> vec4f {
      let id = 3 * faces[3 * face_id + vtx_id];
      return vec4f(vtx[id + 0], vtx[id + 1], vtx[id + 2], 1.);
    }
  `;

function create_visu_pipeline1(render) {  // BVH method
  const visu_code = `
    ${visu_uniforms_struct_code}
    @group(0) @binding(0) var<uniform> params: Uniforms;
    @group(0) @binding(1) var<storage, read> vtx: array<f32>;
    @group(0) @binding(2) var<storage, read> faces: array<u32>;

    ${common_code}

    struct Out {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
    };

    @vertex fn vtx_main(@builtin(vertex_index) idx: u32)
        -> Out {
        _ = params.width;
        const kVtx = array<vec2f, 3>(vec2f(-1., 3.), vec2f(3., -1.), vec2f(-1., -1.));
        var s : Out;
        s.position = vec4f(kVtx[idx], 1., 1.);
        s.uv = s.position.xy;
        return s;
    }

    struct Hit {
      hit: bool,
      pos: vec3f,
      N: vec3f,
      uv: vec2f,  // hit coordinate
      z:  f32,    // distance along ray
    };
    // Möller and Trumbore, « Fast, Minimum Storage Ray-Triangle Intersection »
    fn intersects(orig: vec3f, dir: vec3f, p0: vec3f, p1: vec3f, p2: vec3f) -> Hit {
      var hit : Hit;
      let d10 = p1 - p0;
      let d20 = p0 - p2;
      hit.N = cross(d20, d10);
      let det = -dot(dir, hit.N);
      let invdet = 1.0 / det;
      let d0  = p0 - orig;
      let nd = cross(d0, dir);
      hit.uv = vec2f(dot(d20, nd), dot(d10, nd)) * invdet;
      hit.z = dot(d0, hit.N) * invdet;
      hit.hit = (det >= 1e-6 && hit.z >= 0.0 && hit.uv.x >= 0.0 && hit.uv.y >= 0.0 && (hit.uv.x + hit.uv.y) <= 1.0);
      hit.pos = orig + hit.z * dir;
      if (hit.hit) { hit.N = normalize(hit.N); }
      return hit;
    }
    fn quick_reject(orig: vec3f, dir: vec3f, p0: vec3f, p1: vec3f, p2: vec3f, best_z: f32) -> bool {
      let z0 = dot(p0 - orig, dir);
      let z1 = dot(p1 - orig, dir);
      let z2 = dot(p2 - orig, dir);
      return (min(min(z0, z1), z2) > best_z);
    }
    
    @fragment fn frag_main(s: Out) -> @location(0) vec4f {
      let dir = normalize(vec3f(-s.uv * params.fxy, 1.));
      let orig = vec3f(0.);
      var best_f : u32 = 0;
      var best_z : f32 = 1e36;
      var best_hit : Hit;
      var best_col = vec3f(0.);
      for (var face : u32 = 0; face < u32(params.nb_tris); face += 1) {
        let p0 = (params.view * get_vtx(face, 0)).xyz;
        let p1 = (params.view * get_vtx(face, 1)).xyz;
        let p2 = (params.view * get_vtx(face, 2)).xyz;
        // if (quick_reject(orig, dir, p0, p1, p2, best_z)) { continue; }
        let hit = intersects(orig, dir, p0, p1, p2);
        if (hit.hit && hit.z < best_z) {
          best_z = hit.z;
          best_f = face;
          best_hit = hit;
          best_col = Hash3f(best_f) * max(0.2,dot(hit.N, params.light.xyz));
        }
      }
      return vec4f(best_col, 1.);
    }
  `;
  const visu_module = render.device.createShaderModule({ code: visu_code, });
  render.visu_pipeline = render.device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: visu_module,
      entryPoint: 'vtx_main',
    },
    fragment: {
      module: visu_module,
      entryPoint: 'frag_main',
      targets: [{
        format: render.textureFormat,
        blend: {
          color: {srcFactor: 'one', dstFactor: 'one-minus-dst-alpha', operation: 'add'},
          alpha: {srcFactor: 'one', dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'none',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'greater',
      format: 'depth24plus',
    },
  });
  render.visu_bind_group = render.device.createBindGroup({
    layout: render.visu_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: render.GPU.uniforms, }, },
      { binding: 1, resource: { buffer: render.GPU.vtx, }, },
      { binding: 2, resource: { buffer: render.GPU.tris, }, },
    ],
  });
}

function create_visu_pipeline0(render) {   // basic method
  const visu_code = `
    ${visu_uniforms_struct_code}
    @group(0) @binding(0) var<uniform> params: Uniforms;
    @group(0) @binding(1) var<storage, read> vtx: array<f32>;
    @group(0) @binding(2) var<storage, read> faces: array<u32>;

    ${common_code}
      
    struct Out {
        @builtin(position) position: vec4f,
        @location(0) n: vec3f,
        @location(1) @interpolate(flat) color: vec3f,
    };
    @vertex fn vtx_main(@builtin(vertex_index) vtx_idx: u32,
                        @builtin(instance_index) face_idx: u32,
                       ) -> Out {
        _ = params.width;
        let face = face_idx;
        var s : Out;
        s.position = params.proj * params.view * get_vtx(face, vtx_idx);
        let p0 = (params.view * get_vtx(face, 0)).xyz;
        let p1 = (params.view * get_vtx(face, 1)).xyz;
        let p2 = (params.view * get_vtx(face, 2)).xyz;
        s.n = normalize(cross(p1 - p0, p2 - p1));
        s.color = .4 * Hash3f(face_idx);
        return s;
    }
    @fragment fn frag_main(s: Out) -> @location(0) vec4f {
      let l = max(0.0, dot(s.n, normalize(vec3f(1., 1., 1.))));
      return vec4f(mix(s.color, vec3f(1., 1., 1.), pow(l, 5.)), 1.);
    }
  `;
  const visu_module = render.device.createShaderModule({ code: visu_code, });
  render.visu_pipeline = render.device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: visu_module,
      entryPoint: 'vtx_main',
    },
    fragment: {
      module: visu_module,
      entryPoint: 'frag_main',
      targets: [{
        format: render.textureFormat,
        blend: {
          color: {srcFactor: 'one', dstFactor: 'one-minus-dst-alpha', operation: 'add'},
          alpha: {srcFactor: 'one', dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'none',
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: 'greater',
      format: 'depth24plus',
    },
  });
  render.visu_bind_group = render.device.createBindGroup({
    layout: render.visu_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: render.GPU.uniforms, }, },
      { binding: 1, resource: { buffer: render.GPU.vtx, }, },
      { binding: 2, resource: { buffer: render.GPU.tris, }, },
    ],
  });
}

function create_pipelines(render) {
  switch (params.method) {
    case 0:
    default:
      create_visu_pipeline0(render);
      break;
    case 1:
      create_visu_pipeline1(render);
    break;
  }
}

////////////////////////////////////////////////////////////////////////////////
// Create the data buffers

// https://gist.github.com/tommyettinger/46a874533244883189143505d203312c?permalink_comment_id=4365431#gistcomment-4365431
function splitmix32(seed) {
  seed |= 0;
  seed = seed + 0x9e3779b9 | 0;
  let t = seed ^ seed >>> 16;
  t = Math.imul(t, 0x21f0aaad);
  t = t ^ t >>> 15;
  t = Math.imul(t, 0x735a2d97);
  return ((t = t ^ t >>> 15) >>> 0);  // in [0, 4294967296);
}

function get_random_tris(nb_tris, nb_vtx = 10) {
  const tris = new Uint32Array(nb_tris * 3);
  for (let i = 0; i < nb_tris * 3; i += 3) {
    tris[i + 0] = splitmix32(i + 0) % nb_vtx;
    tris[i + 1] = splitmix32(i + 1) % nb_vtx;
    tris[i + 2] = splitmix32(i + 2) % nb_vtx;
  }
  return tris;
}

async function init_buffers(render) {
  trace(0, "Init buffers() => nb_tris:", render.nb_tris);

  render.nb_tris = Math.floor(BunnyTris.length / 3);
  render.GPU.tris = Create_GPU_Buffer(render.device, BunnyTris, GPUBufferUsage.INDEX);
  render.nb_vtx = Math.floor(BunnyVtx.length / 3);
  render.GPU.vtx = Create_GPU_Buffer(render.device, BunnyVtx, GPUBufferUsage.VERTEX);

  // Create uniforms buffer
  render.GPU.uniforms = render.device.createBuffer({
    size: 44 * 4,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  // depth texture
  render.GPU.depth_texture = render.device.createTexture({
    label: 'depth',
    size: [canvas.width, canvas.height],
    format: 'depth24plus',
    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
    sampleCount: 1,  // no MSAA for now
  });
}

////////////////////////////////////////////////////////////////////////////////

function transmit_frame_params(render) {
  const aspect = canvas.width / canvas.height;
  render.frame.fx = 1. / Math.tan(params.cam.fov * Math.PI / 360.);
  render.frame.fy = aspect * render.frame.fx;
  render.frame.proj = perspective(render.frame.fx, render.frame.fy,
                                  params.cam.znear, params.cam.zfar);
  const theta = params.cam.theta * Math.PI / 180.;
  const phi = params.cam.phi * Math.PI / 180.;
  render.frame.view = look_at(
      [ params.cam.radius * Math.cos(theta) * Math.cos(phi),
        params.cam.radius *                   Math.sin(phi),
        params.cam.radius * Math.sin(theta) * Math.cos(phi), ],
      [0., 0., 0.], [0., 1., 0.]);

  const light_dir = new Float32Array(normalize([1., 1., 1.]), 1.);
  // transmit
  render.device.queue.writeBuffer(render.GPU.uniforms,  0 * 4, render.frame.view);
  render.device.queue.writeBuffer(render.GPU.uniforms, 16 * 4, render.frame.proj);
  render.device.queue.writeBuffer(render.GPU.uniforms, 32 * 4,
      new Float32Array([ render.nb_tris, render.nb_vtx,
                         canvas.width, render.frame.fy / render.frame.fx,
                         1., render.frame.fx / render.frame.fy,
                         0., 0.,
                       ]));
  render.device.queue.writeBuffer(render.GPU.uniforms, 40 * 4, light_dir);
}

////////////////////////////////////////////////////////////////////////////////
// Animation loop

async function frame() {
  const encoder = render.device.createCommandEncoder();
  transmit_frame_params(render);
  const render_pass = encoder.beginRenderPass({
      colorAttachments: [
        { view: ctx.getCurrentTexture().createView(),
          clearValue: {r:0., g:0., b:0., a:0.},
          loadOp: 'clear', storeOp: 'store', },
      ],
      depthStencilAttachment: {
        view: render.GPU.depth_texture.createView(),
        depthClearValue: 0.0,
        depthLoadOp: 'clear', depthStoreOp: 'store', },
  });
  render_pass.setPipeline(render.visu_pipeline);
  render_pass.setBindGroup(0, render.visu_bind_group);
  if (params.method == 0) {
    render_pass.draw(3, render.nb_tris);
  } else {
    render_pass.draw(3);
  }
  render_pass.end();

  render.device.queue.submit([encoder.finish()]);
  if (params.cam.auto_rotate) params.cam.theta -= 0.07;
  render.loop_id = requestAnimationFrame(frame);

  render.txt_info = render.nb_spins;
}

function stop_animation() {
  if (render.loop_id != undefined) {
    cancelAnimationFrame(render.loop_id);
    render.loop_id = undefined;
  }
}

////////////////////////////////////////////////////////////////////////////////

var render = {  /* Run-time data: device, uniforms, pipeline... */
  device: undefined,
  textureFormat: undefined,

  nb_tris:     0,   // final number of tris
  nb_vtx:      0,   // final number of vtx
  GPU: {   // data sent to GPU
    tris:         null,
    uniforms:     null,
  },

  // per-frame params
  frame: {
    view: undefined,
    proj: undefined,
    fx: undefined,
    fy: undefined,
  },

  // side info
  txt_info: "",
  loop_id: undefined,  // id for animation loop
};

async function init() {
  render.device || Oops("Initialization failed. Is WebGPU supported and " +
                        "<a href='https://github.com/gpuweb/gpuweb/wiki/Implementation-Status'>enabled</a>?");
  stop_animation();

  init_buffers(render);
  create_pipelines(render);

  frame();    // start animation loop
}

async function main() {
  try {
    await GPU_init();
    GUI_init();
    await init();
  } catch(e) { Oops(e); }
}

</script>

</body>
</html>
