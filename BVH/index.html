<!-- skal/ (pascal.massimino@gmail.com) 2025 -->
<!-- Bound Volume Hierarchy -->

<!DOCTYPE html>
<html>

<head>
<title>BVH</title>
<link rel="stylesheet" href="../splats/style.css">
</head>

<body onload="main();">
<div id='main-area'>
  <center>
    <b>BVH</b><br/>
    <div><canvas id="main-canvas"'></canvas></div>
    <form action="https://skal65535.github.io/">
      <input type="submit" value="skal 2025" id="skal-back"/>
    </form>
    <br/>
  </center>
    <br/>
</div>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script src="../common/args.js"></script>
<script src="../common/matrix.js"></script>
<script src="./bunny.js"></script>
<script>
"use strict";

////////////////////////////////////////////////////////////////////////////////

const trace = (level, ...args) => {
  if (params.dbg.trace > level) console.log(args.join(' '));
}

////////////////////////////////////////////////////////////////////////////////
// constants

const canvas = document.querySelector("#main-canvas");
const ctx = canvas.getContext("webgpu");

////////////////////////////////////////////////////////////////////////////////
// Params

const params = {
  tris: null,  // triangles struct, as UInt32Array
  vtx: null,  // vertex, as vec3f

  wsize: 256,            // maxComputeInvocationsPerWorkgroup,
  wsize_max: 65535,      // maxComputeWorkgroupsPerDimension
  max_buffer_size: 268435456,

  gui: null,

  // Camera / Visu
  cam: {
    fov: 90.,
    radius: 1.5,
    theta: 0.,
    phi: -30.0,
    znear: 0.1,
    zfar: 100.,
    auto_rotate: !parse_arg_bool("no-rotate"),
  },
  mouse: {on:false, x:0., y:0.},

  // debugging
  dbg: { timing: parse_arg_bool('timing'),
         trace: parse_arg('trace', 0, 0, 3),
       },
  no_gui: parse_arg_bool('no-gui'),
};

if (parse_arg_bool("dbg")) {
  params.dbg.trace = 0;
  params.dbg.timing = false;
}

////////////////////////////////////////////////////////////////////////////////
// GUI setup

const GUI_change = async () => { await init(); }  // parameter changed

const GUI_init = () => {
  canvas.width  = parse_arg("w", innerWidth * .9);
  canvas.height = parse_arg("h", innerHeight * .8);

  if (params.no_gui) {
    params.gui = undefined;
    return;
  }
  params.gui = new lil.GUI({container: document.getElementById('#main-area'), name: 'Ising model'});
  const cam_folder = params.gui.addFolder('camera / visu').close();
  cam_folder.add(params.cam, 'fov', 0., 180., 5.).listen();
  cam_folder.add(params.cam, 'radius', 0.0001, 100., 0.01).listen();
  cam_folder.add(params.cam, 'theta', 0., 360., 1.).listen();
  cam_folder.add(params.cam, 'phi', -180., 180., 1.).listen();
  cam_folder.add(params.cam, 'auto_rotate').name('auto rotate').listen();
  const dbg_folder = params.gui.addFolder('Debug').close();
  dbg_folder.add(params.dbg, 'timing').name('print timing').listen();
  dbg_folder.add(params.dbg, 'trace', 0, 3, 1).name('trace level').listen();
  params.gui.add(render, 'txt_info').name('fps').listen().disable();

  params.gui.domElement.style.top = '5%';
  params.gui.domElement.style.right = '3%';
}

////////////////////////////////////////////////////////////////////////////////
// event handling

window.addEventListener('pointermove', (event) => {
  if (event.target != canvas) return;
  event.preventDefault();
  const bounds = canvas.getBoundingClientRect();
  const mouse_x = (event.clientX - bounds.left) / canvas.width;
  const mouse_y = (event.clientY -  bounds.top) / canvas.height;
  if (params.mouse.on) {
    params.cam.phi   += (params.mouse.y - mouse_y) * 140.;
    params.cam.theta += (params.mouse.x - mouse_x) * 140.;
  }
  params.mouse.x = mouse_x;
  params.mouse.y = mouse_y;
}, false);
window.addEventListener('pointerdown', (event) => {
  if (event.target == canvas) params.mouse.on = true;
});
window.addEventListener('pointerup', (event) => {
  params.mouse.on = false;
});
window.addEventListener('wheel', (event) => {
  if (event.target != canvas) return;
  event.preventDefault();
  params.cam.radius *= (event.deltaY > 0.) ? 1.05 : 1. / 1.05;
}, { passive: false });

window.addEventListener("resize", (e) => {
  canvas.width  = innerWidth  * .9;
  canvas.height = innerHeight * .8;
  do_resize();
});

function do_resize() {
}

////////////////////////////////////////////////////////////////////////////////
////// WebGPU init //////

function Oops(e) {
  document.body.innerHTML = `Oops! <pre>${e}</pre>`;
  throw Error(e);
}

const GPU_init = async () => {
  navigator.gpu || Oops("WebGPU not supported.");
  console.log("Navigator has GPU");

  const adapter = await navigator.gpu.requestAdapter();
  adapter || Oops("Couldn’t request WebGPU adapter.");
  console.log("WebGPU Adapter ok");

  render.device = await adapter.requestDevice();
  render.device || Oops("Couldn’t request WebGPU logical device.");
  console.log("WebGPU Device acquired.");
  for (const name of ['maxComputeInvocationsPerWorkgroup',
                      'maxComputeWorkgroupSizeX',
                      'maxComputeWorkgroupSizeY',
                      'maxComputeWorkgroupSizeZ',
                      'maxComputeWorkgroupStorageSize',
                      'maxComputeWorkgroupsPerDimension',
                      'maxStorageBufferBindingSize']) {
    console.log("  ->", name, ":", render.device.limits[name]);
  }
  params.wsize = render.device.limits['maxComputeInvocationsPerWorkgroup'];
  params.wsize_max = render.device.limits['maxComputeWorkgroupsPerDimension'];

  params.max_buffer_size = render.device.limits.maxBufferSize;
  params.max_binding_size = render.device.limits.maxStorageBufferBindingSize;

  function onDeviceError(event) {
    console.log("Something bad happened! Error type:", event.error.constructor.name);
    console.log("Error message:", event.error.message);
    if (render.device != undefined) {
      render.device.destroy();
      render.device = undefined;
    }
    stop_animation();
    Oops("Error caught while constructing the WebGPU device. See console.");
  }
  render.device.addEventListener('uncapturederror', onDeviceError);

  render.textureFormat = navigator.gpu.getPreferredCanvasFormat();
  ctx.configure({device: render.device,
                 format: render.textureFormat,
                 usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                 alphaMode: 'premultiplied', });
}

////////////////////////////////////////////////////////////////////////////////
// Pipelines & Shaders (the cool stuff!)

const visu_uniforms_struct_code = `
    struct Uniforms {
      view: mat4x4f,
      proj: mat4x4f,
      nb_tris:     f32,   // 32 * 4
      nb_vertex:   f32,
      width:       f32,
      aspect:      f32,
    }
  `;
function create_visu_pipeline(render) {  // RENDER pipeline drawing the spins
  const visu_code = `
    ${visu_uniforms_struct_code}
    struct Out {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
    };
    @group(0) @binding(0) var<uniform> params: Uniforms;
//    @group(0) @binding(1) var<storage, read> tris: array<vec3u>;
    @vertex fn vtx_main(@builtin(vertex_index) idx: u32)
        -> Out {
        _ = params.width;
//        _ = tris[0];
        const kVtx = array<vec2f, 3>(
            vec2f(0.,2.), vec2f(2.,0.), vec2f(0.,0.),
        );
        var s : Out;
        s.position = vec4f(2. * kVtx[idx] - vec2f(1., 1.), 1., 1.);
        s.uv = s.position.xy;
        return s;
    }
    @fragment fn frag_main(s: Out) -> @location(0) vec4f {
      // let orig = normalize(vec4f(s.uv, params.fov
      let uv = s.uv;
      if (dot(uv, uv) > 1.) { discard; }
      return vec4f(1. - length(uv), length(uv), .1, 1.);
    }
  `;
  const visu_module = render.device.createShaderModule({ code: visu_code, });
  render.visu_pipeline = render.device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: visu_module,
      entryPoint: 'vtx_main',
    },
    fragment: {
      module: visu_module,
      entryPoint: 'frag_main',
      targets: [{
        format: render.textureFormat,
        blend: {
          color: {srcFactor: 'one', dstFactor: 'one-minus-dst-alpha', operation: 'add'},
          alpha: {srcFactor: 'one', dstFactor: 'one', operation: 'add'},
        },
      },],
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'none',
    },
  });
  render.visu_bind_group = render.device.createBindGroup({
    layout: render.visu_pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: render.GPU.uniforms, }, },
//      { binding: 1, resource: { buffer: render.GPU.tris, }, },
    ],
  });
}

function create_pipelines(render) {
  create_visu_pipeline(render);
}

////////////////////////////////////////////////////////////////////////////////
// Create the data buffers

// https://gist.github.com/tommyettinger/46a874533244883189143505d203312c?permalink_comment_id=4365431#gistcomment-4365431
function splitmix32(seed) {
  seed |= 0;
  seed = seed + 0x9e3779b9 | 0;
  let t = seed ^ seed >>> 16;
  t = Math.imul(t, 0x21f0aaad);
  t = t ^ t >>> 15;
  t = Math.imul(t, 0x735a2d97);
  return ((t = t ^ t >>> 15) >>> 0);  // in [0, 4294967296);
}

function get_random_tris(nb_tris, nb_vtx = 10) {
  const tris = new Uint32Array(nb_tris * 3);
  for (let i = 0; i < nb_tris * 3; i += 3) {
    tris[i + 0] = splitmix32(i + 0) % nb_vtx;
    tris[i + 1] = splitmix32(i + 1) % nb_vtx;
    tris[i + 2] = splitmix32(i + 2) % nb_vtx;
  }
  return tris;
}

async function init_buffers(render) {
  trace(0, "Init buffers() => nb_spins:", render.nb_spins);

  // Create the persistent GPU buffers that will be filled progressively
  render.GPU.tris = render.device.createBuffer({
    size: render.nb_tris * 4,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX |
           GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true,
  });
  const tris = get_random_tris(render.nb_tris);
  new Uint32Array(render.GPU.tris.getMappedRange()).set(tris);
  render.GPU.tris.unmap();

  // Create uniforms buffer
  render.GPU.uniforms = render.device.createBuffer({
    size: 36 * 4,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
}

////////////////////////////////////////////////////////////////////////////////

function transmit_frame_params(render) {
  const aspect = canvas.width / canvas.height;
  render.frame.fx = 1. / Math.tan(params.cam.fov * Math.PI / 360.);
  render.frame.fy = aspect * render.frame.fx;
  render.frame.proj = perspective(render.frame.fx, render.frame.fy,
                                  params.cam.znear, params.cam.zfar);
  const theta = params.cam.theta * Math.PI / 180.;
  const phi = params.cam.phi * Math.PI / 180.;
  render.frame.view = look_at(
      [ params.cam.radius * Math.cos(theta) * Math.cos(phi),
        params.cam.radius *                   Math.sin(phi),
        params.cam.radius * Math.sin(theta) * Math.cos(phi), ],
      [0., 0., 0.], [0., 1., 0.]);

  // transmit
  render.device.queue.writeBuffer(render.GPU.uniforms,  0 * 4, render.frame.view);
  render.device.queue.writeBuffer(render.GPU.uniforms, 16 * 4, render.frame.proj);
  render.device.queue.writeBuffer(render.GPU.uniforms, 32 * 4,
      new Float32Array([ render.nb_tris, render.nb_vtx,
                         canvas.width, render.frame.fy / render.frame.fx, ]));

}

////////////////////////////////////////////////////////////////////////////////
// Animation loop

async function frame() {
  const encoder = render.device.createCommandEncoder();
  transmit_frame_params(render);
  const render_pass = encoder.beginRenderPass({
      colorAttachments: [
        { view: ctx.getCurrentTexture().createView(),
          clearValue: {r:0., g:0., b:0., a:0.},
          loadOp: 'clear', storeOp: 'store', },
      ],
/*
      depthStencilAttachment: {
        view: render.depthTexture.createView(),
        depthClearValue: 0.0,
        depthLoadOp: 'clear', depthStoreOp: 'store', },
*/
  });
  render_pass.setPipeline(render.visu_pipeline);
  render_pass.setBindGroup(0, render.visu_bind_group);
  render_pass.draw(3);
  render_pass.end();

  render.device.queue.submit([encoder.finish()]);
  if (params.cam.auto_rotate) params.cam.theta -= 0.07;
  render.loop_id = requestAnimationFrame(frame);

  render.txt_info = render.nb_spins;
}

function stop_animation() {
  if (render.loop_id != undefined) {
    cancelAnimationFrame(render.loop_id);
    render.loop_id = undefined;
  }
}

////////////////////////////////////////////////////////////////////////////////

var render = {  /* Run-time data: device, uniforms, pipeline... */
  device: undefined,
  textureFormat: undefined,

  nb_tris:     0,   // final number of tris
  nb_vertex:   0,   // final number of tris
  GPU: {   // data sent to GPU
    tris:         null,
    uniforms:     null,
  },

  // per-frame params
  frame: {
    view: undefined,
    proj: undefined,
    fx: undefined,
    fy: undefined,
  },

  // side info
  txt_info: "",
  loop_id: undefined,  // id for animation loop
};

async function init() {
  render.device || Oops("Initialization failed. Is WebGPU supported and " +
                        "<a href='https://github.com/gpuweb/gpuweb/wiki/Implementation-Status'>enabled</a>?");
  stop_animation();

  init_buffers(render);
  create_pipelines(render);

  frame();    // start animation loop
}

async function main() {
  try {
    GUI_init();
    await GPU_init();
    init();
    do_resize();
  } catch(e) { Oops(e); }
}

</script>

</body>
</html>
