<!--
Demo page for Sharp-YUV algorithm.
skal/ (pascal.massimino@gmail.com) 2025
 -->
<!DOCTYPE html>
<html>

<head>
<title>Sharp-YUV: sharp conversion to YUV420</title>
<link rel="stylesheet" href="../splats/style.css">
<style>
.canvas {
  position: absolute;
  z-index:0;
  border: 2px solid #000; border-radius: 20px;
  margin: 0px;
  background: #000;
  box-shadow: 0 0 8px black;
  outline: 1px solid black;
}

#main-area.highlight { border-color: purple; }
.button {
  display: inline-block;
  padding: 4px;
  background: #bbc;
  cursor: pointer;
  border-radius: 5px;
  border: 2px solid #334;
  z-index:1;
  position:relative;
  font-size: 14px;
}
.button:hover {
  background: #cce;
}
#arrow-svg {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;  /* pass-through clicks */
  z-index: 10;  /* on top */
}
#popup-rgb {
  position: absolute;
  display: none;
  background-color: #333;
  color: white;
  padding: 10px;
  border-radius: 5px;
  font-family: Arial, 10pt, bold sans-serif;
  z-index: 1000;
  pointer-events: none;
}

.floating {
  position: relative;
  left: 50%;
  transform: translate(-50%, 0%);
  text-align: left;
  overflow-wrap: break-word;
  z-index: 10;
}
.stroke_text {
  font-weight: bold;
  color: white;
  font-family: 'Arial', sans-serif;
  font-size: 1.5em;
  text-shadow:
    -1px -1px 0 #000,
     1px -1px 0 #000,
    -1px  1px 0 #000,
     1px  1px 0 #000;

}

.lil-gui {
  --font-size: 15px;
  --input-font-size: 15px;
  --width: 400px;
}
</style>
</head>

<body onload="main();">

<svg id='arrow-svg'></svg>
<div id="main-area">
  <div height='100px'>
    <h2><center>the Sharp-YUV conversion technique, illustrated<br></center></h2>
    This page showcases some RGB->YUV420 conversion techniques usable before
    JPEG/WebP/AVIF compression. <br/>
    The 'fast' one is the simplest and less CPU-intensive. But it falls short on some
    classes of images shown below (thumbnails, screen-capture, ads...).<br/>
    To remediate this, we present the 'Sharp-YUV' technique used in WebP,
    along with a new one ("new").<br/>
    They better capture edges and vivid colors, while staying in YUV420 downsampled format.
    We utilise the upsampling used at decoding time (dubbed "fancy
    upsampling" in libjpeg e.g.) to our advantage.<br/>
    Sharp-YUV locally optimizes the conversion loss, so is more expensive. That's why
    <code>-sharp_yuv</code> is not the default option in <code>cwebp</code>!
    <br/>
    <b>Quick keys</b>: 1/2/3 to change algo. Use SPACE to view the original.</br>
  </div>
  <hr>

  <form class="my-form">
    <input type="file" id="FileElmt" style='display:none;'
           multiple accept="image/*" onchange="HandleFile(this.files[0])">
  </form>

  <div id="gui-container">
    <canvas id="ref-rgb" style='position:relative; bottom:40px; left:20px; border: 2px solid #334;'></canvas>
    <canvas id="main-canvas" style=''></canvas>
    <br/>
    <div id='desc' class="stroke_text floating" style='width:30%%; top: 15%; background-color:#8888;'></div><br/>
    <table style='border: 1px solid black;'>
      <tr id='tr'>
        <td valign='top'><canvas id="yuv" width='256px' height='384px'></canvas></td>
        <td valign='top'><canvas id="rgb" width='256px' height='256px'></canvas></td>
        <td valign='top'><canvas id="err" width='256px' height='256px'></canvas></td>
      </tr>
      <tr><th>Y/U/V</th><th>converted RGB</th><th>error map</th></tr>
    </table>
    <div id="popup-rgb">
      <span id="rgb-value"></span>
    </div>
<hr>
    <font size='-1'>
    Drag and drop image on the canvas above.
    Or <label class='button' for="FileElmt">select an image</label>.<br/>
    </font>
    <font size='-1'>
    Mouse-click will move the zoom area.<br/>
    Mouse-Wheel will change the zoom level<br/>
    Canvas key:
    <ul>
      <li><code>1/2/3</code> display RGB for fast / reference /new sharp-YUV algo</li>
      <li><code>f</code> to toggle fancy upscaler</li>
      <li><code>g</code> to toggle gamma correction</li>
      <li><code>space</code> to show the source in reconstructed RGB</li>
    </ul>
    <br/>
    </font>
  </div>
</div>
<form action="https://skal65535.github.io/" >
  <input type="submit" value="skal 2025" id="skal-back" style='position:relative; left:1%;'/>
</form>

<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.20"></script>
<script src="../common/args.js"></script>
<script src="../common/utils.js"></script>
<script src="./arrow.js"></script>
<script src="./yuv.js"></script>
<script src="./drag.js"></script>

<script>
"use strict";

const kImages = {
  'Smeared Colors': { file: "combo.png", POI: {x: 160, y: 100}, zoom: 60, YUV_W: 320,
                      desc: "Some color combinations smear more than others.<br/>Blue, pink and yellow in particular.", },
  'YouTube Thumbnail': { file: "hq720.jpg", POI: {x: 96, y: 250}, zoom: 50, YUV_W:208, desc: "Thumbnails typically use vivid colors", },
  'chrome icon': { file: "Chrome_icon.png", POI: {x: 122, y: 222}, desc: "sharp edges between saturated colors" },
  'Netflix logo': { file: "Logonetflix.png", POI: {x: 250, y: 30}, YUV_W: 80, desc: "Red on black is hard" },
  'Cover': { file: "cover.png", POI: {x: 213, y: 114}, desc:"the problem here is visible around the red circle, that gets darker after conversion", },
  // magick input.png -resize 512x -colors 16 -ordered-dither o8x8 dithered.png
  'dithered': { file: "dithered.png", POI: {x: 229, y: 240}, desc: "Dithering patterns make the converted image 'darker'" },
  'blue text': { file: "difficult_blue.png", POI: {x: 61, y: 38}, desc: "Fonts are hard to preserve when the background is not black or white" },
  'graff': { file: "test_yuv.png", POI: {x: 129, y: 71} },
  'anime-1': { file: "x1.png", POI: {x: 82, y: 381}, desc: "lot of difficult red objects"  },
  'anime-2': { file: "x2.png", POI: {x: 369, y: 223}, desc: "difficult red/black combinations, and yellow too" },
};

const kAlgoNames = ["Fast", "WebP ref.", "New"];
function AlgoId(name) {
  return Math.max(kAlgoNames.indexOf(name), 0);
}

class AlgoOutput {
  constructor(algo) {
    this.Y = new Uint8ClampedArray(params.W * params.H);
    this.U = new Uint8ClampedArray(params.w * params.h);
    this.V = new Uint8ClampedArray(params.w * params.h);
    this.RGB = new ImageData(params.W, params.H);
    this.ERR = new ImageData(params.W, params.H);
    this.psnr = 99.;
    this.draw(kAlgoNames[algo]);
  }
  draw(algo) {
    if (algo == kAlgoNames[0]) {
      convert_to_yuv_fast(params.RGB.data, this.Y, this.U, this.V, params.delta);
    } else if (algo == kAlgoNames[1]) {
      convert_to_yuv_sharp_ref(params.RGB.data, this.Y, this.U, this.V, params.W, params.H, params.iters);
    } else {
      convert_to_yuv_sharp(params.RGB.data, this.Y, this.U, this.V, params.W, params.H, params.iters);
    }
  }
  to_rgb() {
    const err2 = convert_to_rgb(this.Y, this.U, this.V, this.RGB, this.ERR);
    this.psnr = PSNR(err2);
  }
  render(x, y, w, h) {
    const S = params.YUV_W;
    const s = (S + 1) >> 1;

    draw_yuv('yuv', this.Y, params.W, x, y, w, h,  0, 0, S, S, "Y");
    draw_yuv('yuv', this.U, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  0, S, s, s, "U");
    draw_yuv('yuv', this.V, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  s, S, s, s, "V");
    draw_to('err', this.ERR, x, y, w, h, `PSNR: ${this.psnr} dB`);
    if (params.show_src) {
      draw_to('rgb', params.RGB, x, y, w, h, "source");
    } else {
      draw_to('rgb', this.RGB, x, y, w, h, params.algo);
    }
  }
}

const params = {
  // user-controlled params
  image_name: Object.keys(kImages)[parse_arg('image', 0, 0, Object.keys(kImages).length - 1)],
  iters: parse_arg('iters', 6, 1, 8),
  zoom: parse_arg('zoom', 50, 1, 100),
  fancy_upscaler: !parse_arg_bool('no_fancy'),
  algo: kAlgoNames[parse_arg('algo', 2, 0, 2)],
  delta: parse_arg('delta', 1, 1, 8),
  gamma_aware: !parse_arg_bool('no_gamma'),
  gamma: parse_arg('gamma', 1.2, 0.25, 4.),
  exit_threshold: parse_arg('exit', .3, 0.0, 0.5),
  YUV_W: parse_arg('size', 256, 64, 512),
  // max dimension for the input image (resized to fit)
  Wo: parse_arg('Wo', 512, 256, 1024),
  Ho: parse_arg('Ho', 512, 256, 1024),
  debug: parse_arg_bool('debug'),
  show_sharp: !parse_arg_bool('fast'),
  no_gui: parse_arg_bool('no_gui'),

  // internal rendering state
  POI: {x: 0, y: 0},
  desc: "",  // description
  show_src: false,

  RGB: undefined,  // reference input

  // different algo rendition
  out: [null, null, null],

  Ys: undefined,   // Y-sharp internal
  Us: undefined,   // U-sharp internal
  Vs: undefined,   // V-sharp internal
  RGBs: undefined,   // RGB-sharp output
  ERRs: undefined,   // RGB-sharp error

  Yn: undefined,   // Y-sharp internal
  Un: undefined,   // U-sharp internal
  Vn: undefined,   // V-sharp internal
  RGBn: undefined,   // RGB-new-sharp output
  ERRn: undefined,   // RGB-new-sharp error

  // gamma look-up tables
  gLUT: null,
  gLUT_inv: null,

  gui: null,

  W: 0,
  H: 0,
  w: 0,
  h: 0,
  Wr: 0,
  Hr: 0,

  set_POI: (x, y) => {
    const canvas = document.querySelector("#main-canvas");
    const bounds = canvas.getBoundingClientRect();
    params.POI.x = Math.floor(x - bounds.left);
    params.POI.y = Math.floor(y - bounds.top);
  },
  get_box: () => {
    const S = Math.floor(Math.pow(2., params.zoom / 10.));
    const X = params.POI.x - S;
    const Y = params.POI.y - S;
    return [X, Y, 2 * S, 2 * S];  // TODO: make coords even?
  },
};

////////////////////////////////////////////////////////////////////////////////

function PSNR(err2) {
  const x = 10. * Math.log10(255 * 255 * 3. / err2);
  return (Math.round(x * 100.) / 100.).toFixed(2);
}

function set_yuv_size(name) {
  const S = params.YUV_W;
  const Suv = (S + 1) >> 1;
  const canvas = document.getElementById(name);
  canvas.width = S;
  canvas.height = S + Suv;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.font = "18px serif";
}

function set_size(name) {
  const canvas = document.getElementById(name);
  canvas.width = params.YUV_W;
  canvas.height = params.YUV_W;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.font = "17px serif";
}

function update_canvas_dimensions() {
  // make sure it's even
  params.YUV_W = (params.YUV_W + 1) & ~1;

  set_size('ref-rgb');

  set_yuv_size('yuv');
  set_size('rgb');
  set_size('err');
}

function compute_everything(image) {
  compute_gamma_LUT();

  params.out[0] = new AlgoOutput(0);
  params.out[1] = new AlgoOutput(1);
  params.out[2] = new AlgoOutput(2);

  convert_images_to_rgb();
}

function convert_images_to_rgb() {
  params.out[0].to_rgb();
  params.out[1].to_rgb();
  params.out[2].to_rgb();
}

////////////////////////////////////////////////////////////////////////////////

function compute_gamma_LUT() {
  const gamma = params.gamma_aware ? params.gamma : 1.;

  const GPRECISION = 16;
  const NORM = 256 * GPRECISION;
  params.gLUT = new Float32Array(256);
  params.gLUT_inv = new Int16Array(NORM);

  function to_linear(x, gamma) { return Math.pow(x / 256., gamma); }
  function to_gamma(x, gamma) { return Math.pow(x, 1. / gamma); }

  for (let x = 0; x < 256; ++x) params.gLUT[x] = to_linear(x, gamma);
  for (let x = 0; x < NORM; ++x) params.gLUT_inv[x] = Math.round(256. * to_gamma(x / NORM, gamma));

  // input: [0..255] -> output: [0..1]
  params.to_linear = (x) => { return params.gLUT[Math.floor(x)]; }
  // input: [0..1] -> output: [0..255]
  params.to_gamma = (x) => { return params.gLUT_inv[Math.floor(x * NORM)]; }
}

////////////////////////////////////////////////////////////////////////////////

const GUI_change = async () => { await render(); }
const GUI_reload = async () => { await draw(); }
const GUI_convert = async () => { convert_images_to_rgb(); draw(); }

const GUI_init = () => {
  if (params.no_gui) {
    params.gui = undefined;
    return;
  }

  params.gui = new lil.GUI({container: document.querySelector("gui-container"), name: 'Sharp-YUV'});
  params.gui.add(params, 'image_name', Object.keys(kImages)).name('source image').listen()
    .onChange(() => { set_local_image(kImages[params.image_name]); render(); });
  params.gui.add(params, 'algo', kAlgoNames).name('sharp algo').listen().onChange(GUI_change);
  params.gui.add(params, 'exit_threshold', .0, .5, 0.001).name('exit threshold').listen().onChange(GUI_change);
  params.gui.add(params, 'iters', 1, 8, 1).name('iterations').listen().onChange(GUI_change);
  params.gui.add(params, 'gamma_aware').name('gamma-corrected').listen().onChange(GUI_change);
  params.gui.add(params, 'gamma', 0.25, 4., .05).name('gamma').listen().onChange(GUI_change);
  params.gui.add(params, 'fancy_upscaler').name('fancy upscaler').listen().onChange(GUI_convert);
  params.gui.add(params, 'delta', 1, 8, 1).name('U/V averaging size').listen().onChange(GUI_change);
  params.gui.add(params, 'zoom', 1, 100, 1).name('zoom level').listen().onChange(GUI_reload);
  params.gui.add(params, 'YUV_W', 64, 512, 16).name('source zoom level').listen().onChange(
    () => { update_canvas_dimensions(); draw(); }
  );
  params.gui.domElement.style.top = '40%';

//   make_draggable('ref-rgb', draw);
}

////////////////////////////////////////////////////////////////////////////////

function draw_text(ctx, text, x, y) {
  if (text != undefined) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.strokeText(text, x, y);
    ctx.lineWidth = 1;

    ctx.shadowColor = '#000a';
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#fff';
    ctx.fillText(text, x, y);

    // reset
    ctx.shadowColor = 'transparent';
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
  }
}

function draw_image_into(dst_name, img) {
  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  dst_ctx.fillStyle = '#000';
  dst_ctx.fillRect(0, 0, dst.width, dst.height);
  dst_ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, dst.width, dst.height);
}

function draw_to(dst_name, src_data, x, y, w, h, text) {
  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  dst_ctx.clearRect(0, 0, dst.width, dst.height);

  const off_canvas = document.createElement('canvas');
  off_canvas.width = w;
  off_canvas.height = h;
  const off_ctx = off_canvas.getContext("2d");
  off_ctx.putImageData(src_data, -x, -y, x, y, w, h);
  dst_ctx.drawImage(off_canvas, 0, 0, w, h, 0, 0, dst.width, dst.height);

  draw_text(dst_ctx, text, 4, 20);
}


function draw_yuv(dst_name, data, stride, xo, yo, w, h, Xo, Yo, Wo, Ho, text) {
  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  const y_dst = dst_ctx.getImageData(Xo, Yo, Wo, Ho);
  const scale_y = h / Ho;
  const scale_x = w / Wo;
  for (let y = 0; y < Ho; ++y) {
    const yy = Math.min(yo + Math.floor(y * scale_y), params.H - 1);
    for (let x = 0; x < Wo; ++x) {
      const xx = Math.min(xo + Math.floor(x * scale_x), params.W - 1);
      const v = data[xx + yy * stride];
      const off = (x + y * Wo) * 4;
      y_dst.data[off + 0] = v;
      y_dst.data[off + 1] = v;
      y_dst.data[off + 2] = v;
      y_dst.data[off + 3] = 255;
    }
  }
  dst_ctx.putImageData(y_dst, Xo, Yo);
  dst_ctx.strokeStyle = '#000';
  dst_ctx.lineWidth = 1;
  dst_ctx.strokeRect(Xo, Yo, Wo - 1, Ho - 1);
  draw_text(dst_ctx, text, Xo + 3, Yo + 20);
}

function draw() {
  const canvas = document.querySelector("#main-canvas");
  const ctx = canvas.getContext("2d");

  if (!params.show_src) {
    ctx.putImageData(params.RGB, 0, 0);
  } else {
    ctx.putImageData(params.out[AlgoId(params.algo)].RGB, 0, 0);
  }
  ctx.fillStyle = "#eee";
  if (!params.show_src) {
    ctx.fillText("Source", 10, 20);
  } else {
    ctx.fillText("Conversion", 10, 20);
  }

  const [x, y, w, h] = params.get_box();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#000";
  ctx.strokeRect(x + 1, y + 1, w, h);
  ctx.strokeStyle = "#eee";
  ctx.setLineDash([4]);
  ctx.strokeRect(x, y, w, h);
  ctx.setLineDash([]);

  draw_to('ref-rgb', params.RGB, x, y, w, h, "source");

  const desc = document.getElementById('desc');
  desc.innerHTML = params.desc;

  params.out[AlgoId(params.algo)].render(x, y, w, h);
  draw_arrows();
}

////////////////////////////////////////////////////////////////////////////////

function import_image(image, info) {
  let Wo = params.Wo, Ho = params.Ho;
  let W = image.width, H = image.height;
  console.log(`size in: ${W} x ${H} in max canvas: ${Wo} x ${Ho}`);
  if (W > Wo || H > Ho) {   // needs resizing?
    if (W * Ho > Wo * H) {
      H = Math.floor(H * Wo / W);
      W = Wo;
    } else {
      W = Math.floor(W * Ho / H);
      H = Ho;
    }
  }
  console.log(`adjusting to size: ${W} x ${H}`);

  const canvas = document.querySelector("#main-canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // save the definitive RGB source for later
  draw_image_into('main-canvas', image);
  params.RGB = ctx.getImageData(0, 0, W, H);

  params.W = W;
  params.H = H;
  params.w = (W + 1) >>> 1;
  params.h = (H + 1) >>> 1;
  params.POI = (info.POI != null) ? info.POI : { x: (W >>> 1) & ~1, y: (H >>> 1) & ~1, };
  params.zoom = info.zoom || 50;
  params.desc = info.desc || "";
  params.YUV_W = ((info.YUV_W + 15) & ~16) || params.YUV_W;

  render();
}

function set_local_image(image) {
  set_image(`./img/${image.file}`, image);
}

function set_image(src, info = null) {
  let image = new Image();
  image.onload = function() {
    import_image(image, info);
  };
  image.src = src;
}

function render() {
  compute_everything();
  update_canvas_dimensions();
  draw();
}

////////////////////////////////////////////////////////////////////////////////
// Drag'n'Drop

function PreventDefaults (e) {
  e.preventDefault();
  e.stopPropagation();
}
function HandleDrop(e) {
  HandleFile(e.dataTransfer.files[0]);
}
function HandleFile(file) {
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onloadend = function() { set_image(reader.result, { desc:`file: ${file.name}`,}); }
}

async function init_image() {
  const dropArea = document.getElementById('main-area');
  function highlight(e) { dropArea.classList.add('highlight'); }
  function unhighlight(e) { dropArea.classList.remove('highlight'); }

  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, PreventDefaults, false); }
  );
  ['dragenter', 'dragover'].forEach(
    name => { dropArea.addEventListener(name, highlight, false); }
  );
  ['dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, unhighlight, false); }
  );
  dropArea.addEventListener('drop', HandleDrop, false)

  window.addEventListener('resize', draw);
  window.addEventListener('scroll', draw);

  const mouse_move = (e, pos) => {
    e.preventDefault();
    params.set_POI(pos.clientX, pos.clientY);
    draw();
  };
  const canvas = document.getElementById('main-canvas');
  canvas.addEventListener('mousemove', (e) => {
    if (!e.buttons) return;
    mouse_move(e, e);
  });
  canvas.addEventListener('touchmove', (e) => mouse_move(e, e.touches[0]));
  canvas.addEventListener('touchstart', (e) => mouse_move(e, e.touches[0]));

  const handle_wheel = (e) => {
    if (Math.abs(e.wheelDelta) > 3) {
      if (e.shiftKey) {
        params.YUV_W = clamp(params.YUV_W + (e.wheelDelta > 0 ? 16 : -16), 64, 512);
        update_canvas_dimensions();
        draw();
      } else {
        params.zoom = clamp(params.zoom + (e.wheelDelta < 0 ? 1 : -1), 1, 100);
        draw();
      }
    }
    e.preventDefault();
  };

  function display_popup(e, text) {
    const popup = document.getElementById('popup-rgb');
    const W = popup.offsetWidth, H = popup.offsetHeight;
    const x = Math.min(event.clientX + 20 + W, window.innerWidth) - W + window.scrollX;
    const y = Math.min(event.clientY + 20 + H, window.innerHeight) - H + window.scrollY;
    popup.style.left = `${x}px`;
    popup.style.top = `${y}px`;
    popup.style.display = 'block';
    document.getElementById('rgb-value').textContent = text;
  }

  function get_coords(e) {
    const elmt = e.target;
    const rect = elmt.getBoundingClientRect();
    const x = Math.floor(e.clientX - rect.left);
    const y = Math.floor(e.clientY - rect.top);
    const ctx = elmt.getContext('2d');
    const rgb = ctx.getImageData(x, y, 1, 1).data;
    return [elmt, x, y, rgb];
  }

  const show_pixel_values = (e) => {
    const [elmt, x, y, rgb] = get_coords(e);
    const text = `(${x}, ${y}) -> RGB(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
    display_popup(e, text);
  }
  const show_yuv_values = (e) => {
    const [elmt, x, y, rgb] = get_coords(e);
    const text = (y < params.YUV_W)     ? `Y(${rgb[0]})` :
                 (x < params.YUV_W / 2) ? `U(${rgb[0]})` :
                                          `V(${rgb[0]})`;
    display_popup(e, text);
  }
  const hide_popup = (e) => {
    const popup = document.getElementById('popup-rgb');
    popup.style.display = 'none';
  }

  for (const id of ['main-canvas', 'rgb', 'err']) {
    const elmt = document.getElementById(id);
    elmt.addEventListener('wheel', handle_wheel);
    elmt.addEventListener('mousemove', show_pixel_values);
    elmt.addEventListener('mouseenter', show_pixel_values);
    elmt.addEventListener('mouseleave', hide_popup);
  }
  for (const id of ['yuv']) {
    const elmt = document.getElementById(id);
    elmt.addEventListener('mousemove', show_yuv_values);
    elmt.addEventListener('mouseenter', show_yuv_values);
    elmt.addEventListener('mouseleave', hide_popup);
  }
  document.addEventListener('keydown', (e) => {
    if (e.key == 'f') {
      params.fancy_upscaler = !params.fancy_upscaler;
      render();
    } else if (e.key == 'g') {
      params.gamma_aware = !params.gamma_aware;
      render();
    } else if (e.key == ' ') {
      params.show_src = true;
      draw();
    } else if (e.key == '1') {
      params.algo = kAlgoNames[0];
      params.show_src = false;
      draw();
    } else if (e.key == '2') {
      params.algo = kAlgoNames[1];
      params.show_src = false;
      draw();
    } else if (e.key == '3') {
      params.algo = kAlgoNames[2];
      params.show_src = false;
      draw();
    } else if (e.key == 'r') {
      params.algo = kAlgoNames[(AlgoId(params.algo) + 1) % 3];
      params.show_src = false;
      draw();
    } else {
      return;
    }
    e.preventDefault();
  });

  document.addEventListener('keyup', (e) => {
    if (e.key == ' ') {
      params.show_src = false;
      draw();
    } else {
      console.log(`up: ${e.key}`);
      return;
    }
    e.preventDefault();
  });

  set_local_image(kImages[params.image_name]);
}

////////////////////////////////////////////////////////////////////////////////

function draw_arrows() {
  const svg = get_adjusted_svg_container('arrow-svg');
  const options = {
    color: '#fffa',
    stroke: '#000f',
    line_width: 4,
    head_length: 20,
    head_width: 14,
    thickness: 5,
    spike: 1.2,
    drop_limit: 20,
    bend: .4,
  }

  const src = get_element_rectangle('main-canvas');
  const [x, y, w, h] = params.get_box();
  const [x0, y0] = [src.x + x + w / 2, src.y + y + h / 2];

  const dst = get_element_rectangle('ref-rgb');
  if (!is_inside_rectangle(x0, y0, dst)) {
    const [x1, y1] = get_arrow_endpoint(x0, y0, null, null, dst, 1.1);
    svg_draw_arrow(svg, 'line1', x0, y0, x1, y1, options);
  }

  const yuv_dst = get_element_rectangle('yuv');
  let x2 = dst.x + dst.width / 2;
  let y2 = dst.y + dst.height;
  const x3 = Math.floor(yuv_dst.x + yuv_dst.width * .7);
  const y3 = Math.floor(yuv_dst.y + 10);
  [x2, y2] = get_arrow_endpoint(x3, y3, x2, y2, src, 1.1);
  svg_draw_arrow(svg, 'line2', x2, y2, x3, y3, options);

  const rgb_dst = get_element_rectangle('rgb');
  const [x4, y4] = [yuv_dst.x + yuv_dst.width * .9, yuv_dst.y + yuv_dst.height * .3];
  const [x5, y5] = get_arrow_endpoint(x4, y4, null, null, rgb_dst, 2.4);
  console.log(`${x4} ${y4}  ${x5} ${y5}`);
  svg_draw_arrow(svg, 'line3', x4, y4, x5, y5, { ...options, bend: 0.1 });
}

////////////////////////////////////////////////////////////////////////////////

async function main() {
  try {
    if (parse_arg_bool('help')) arg_help();
    await init_image();
    GUI_init();
  } catch(e) { console.log(`Error: ${e};`); }
}

</script>

</body>
</html>
