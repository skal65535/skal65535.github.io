<!--
Explanation page for Sharp-YUV algorithm.
skal/ (pascal.massimino@gmail.com) 2025
 -->
<!DOCTYPE html>
<html>

<head>
<title>Sharp-YUV: sharp conversion to YUV420</title>
<link rel="stylesheet" href="../splats/style.css">
<style>
.canvas {
  position: absolute;
  z-index:0;
  border: 2px solid #000; border-radius: 20px;
  margin: 0px;
  background: #000;
  box-shadow: 0 0 8px black;
  outline: 1px solid black;
}

#main-area.highlight { border-color: purple; }
.button {
  display: inline-block;
  padding: 4px;
  background: #bbc;
  cursor: pointer;
  border-radius: 5px;
  border: 2px solid #334;
  z-index:1;
  position:relative;
  font-size: 14px;
}
.button:hover {
  background: #cce;
}
#gui {
 position: relative;
 top: -230px;
 right: -6px;
}
#arrow-svg {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;  /* pass-through clicks */
  z-index: 10;  /* on top */
}
</style>
</head>

<body onload="main();">
<svg id='arrow-svg'></svg>
<div id="main-area">
  <div height='100px'>
    <h2><center>Illustration of the Sharp-YUV conversion technique</center></h2>
    <font size='-1'>
    Drag and drop image on the canvas below.
    Or <label class='button' for="FileElmt">select an image</label>.<br/>
    Mouse-click will move the zoom area. Mouse-Wheel will change the zoom level<br/>
    Canvas key: <code>f</code> to toggle fancy upscaler. <code>space</code>
    to show the source in reconstructed RGB.<br/>
    </font>
  </div>
  <hr>

  <form class="my-form">
    <input type="file" id="FileElmt" style='display:none;'
           multiple accept="image/*" onchange="HandleFile(this.files[0])">
  </form>

  <div id="gui-container">
    <canvas id="ref-rgb" style='position:relative; bottom:40px; left:20px; border: 2px solid #334;'></canvas>
    <canvas id="main-canvas" style=''></canvas>
    <br/>
    <table border='1px'>
      <tr>
        <th></th>
        <th>Y/U/V</th><th>reconstructed RGB</th><th>error map</th>
      </tr>
      <tr>
        <td style='writing-mode: sideways-rl;'>Regular</td>
        <td valign='top'><canvas id="fast-yuv" width='256px' height='384px'></canvas></td>
        <td valign='top'><canvas id="fast-rgb" width='256px' height='256px'></canvas></td>
        <td valign='top'><canvas id="fast-err" width='256px' height='256px'></canvas></td>
      </tr>
      <tr>
        <td style='writing-mode: sideways-rl;'>Sharp YUV</td>
        <td valign='top'><canvas id="sharp-yuv" width='256px' height='384px' style='left:-2px;'></canvas></td>
        <td valign='top'><canvas id="sharp-rgb" width='256px' height='256px' style='left:-2px;'></canvas></td>
        <td valign='top'><canvas id="sharp-err" width='256px' height='256px' style='left:-2px;'></canvas></td>
      </tr>
    </table>
  </div>
</div>
<form action="https://skal65535.github.io/" >
  <input type="submit" value="skal 2025" id="skal-back" style='position:relative; left:1%;'/>
</form>

<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script src="../common/args.js"></script>
<script src="../common/utils.js"></script>
<script src="./arrow.js"></script>

<script>
"use strict";

const params = {
  original: true,
  iters: 6,
  zoom: 50,
  fancy_upscaler: true,
  gamma_aware: true,
  POI: {x: 0, y: 0},
  show_src: false,

  RGB: undefined,  // reference input
  Yf: undefined,   // Y-fast internal
  Uf: undefined,   // U-fast internal
  Vf: undefined,   // V-fast internal
  Ys: undefined,   // Y-sharp internal
  Us: undefined,   // U-sharp internal
  Vs: undefined,   // V-sharp internal
  RGBf: undefined,   // RGB-fast output
  RGBs: undefined,   // RGB-sharp output
  ERRf: undefined,   // RGB-fast error
  ERRs: undefined,   // RGB-sharp error

  gui: null,
  txt_info: "info",
  dbg: { timing: false, },

  W: 0,
  H: 0,
  w: 0,
  h: 0,
  YUV_W: 128,
  Main_W: 512,
  Main_H: 512,

  set_POI: (x, y) => {
    const canvas = document.querySelector("#main-canvas");
    const bounds = canvas.getBoundingClientRect();
    params.POI.x = Math.floor(x - bounds.left);
    params.POI.y = Math.floor(y - bounds.top);
  },
  get_box: () => {
    const S = Math.floor(Math.pow(2., params.zoom / 10.));
    const X = params.POI.x - S;
    const Y = params.POI.y - S;
    return [X, Y, 2 * S, 2 * S];  // TODO: make coords even?
  },
};

////////////////////////////////////////////////////////////////////////////////

function PSNR(err2) {
  const x = 10. * Math.log10(255 * 255 * 3. / err2);
  return (Math.round(x * 100.) / 100.).toFixed(2);
}

function set_yuv_size(name) {
  const S = params.YUV_W;
  const Suv = (S + 1) >> 1;
  const canvas = document.getElementById(name);
  canvas.width = S;
  canvas.height = S + Suv;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.font = "18px serif";
}

function set_size(name) {
  const canvas = document.getElementById(name);
  canvas.width = params.YUV_W;
  canvas.height = params.YUV_W;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.font = "17px serif";
}

function compute_everything(image) {
  const W = params.W, H = params.H;
  const w = params.w, h = params.h;

  set_size('ref-rgb');

  set_yuv_size('fast-yuv');
  set_size('fast-rgb');
  set_size('fast-err');

  set_yuv_size('sharp-yuv');
  set_size('sharp-rgb');
  set_size('sharp-err');

  params.Yf = new Uint8ClampedArray(W * H);
  params.Uf = new Uint8ClampedArray(w * h);
  params.Vf = new Uint8ClampedArray(w * h);
  convert_to_yuv_fast(params.RGB.data, params.Yf, params.Uf, params.Vf, 1);
  params.RGBf = new ImageData(W, H);
  params.ERRf = new ImageData(W, H);
  const err2_f = convert_to_rgb(params.Yf, params.Uf, params.Vf, params.RGBf, params.ERRf);
  params.psnr_f = PSNR(err2_f);

  params.Ys = new Uint8ClampedArray(W * H);
  params.Us = new Uint8ClampedArray(w * h);
  params.Vs = new Uint8ClampedArray(w * h);
  convert_to_yuv_fast(params.RGB.data, params.Ys, params.Us, params.Vs, 3);
  params.RGBs = new ImageData(W, H);
  params.ERRs = new ImageData(W, H);
  const err2_s = convert_to_rgb(params.Ys, params.Us, params.Vs, params.RGBs, params.ERRs);
  params.psnr_s = PSNR(err2_s);
}

////////////////////////////////////////////////////////////////////////////////

function clamp(v, m, M) { return Math.max(m, Math.min(M, v)); }
function clamp8(v) { return Math.max(0, Math.min(255, v)); }

const GAMMA = 2.2;
const GAMMA_INV = 1. / GAMMA;
function to_linear(x) { return Math.floor(255. * Math.pow(x / 255., GAMMA)); }
function from_linear(x) { return Math.floor(255. * Math.pow(x / 255., GAMMA_INV)); }

function clamp_coord(x, y, w, h) {
  x = clamp(x, 0, w - 1);
  y = clamp(y, 0, h - 1);
  return 4 * (x + y * w);
}

function to_rgb(y, u, v) {  // BT.601
  const R = (19077 * y             + 26149 * v - (14234 << 8)) >> 14;
  const G = (19077 * y -  6419 * u - 13320 * v +  (8708 << 8)) >> 14;
  const B = (19077 * y + 33050 * u             - (17685 << 8)) >> 14;
  return new Uint8ClampedArray([R, G, B]);
}

function filter_9331(a, b, c, d) {
  return (9 * a + 3 * b + 3 * c + d) / 16;
}

function get_rgb(Yo, Uo, Vo, X, Y, W, H) {
  X = clamp(X, 0, W - 1);
  Y = clamp(Y, 0, H - 1);
  const off = X + Y * W;
  const luma = Yo[off];
  const dX = (X & 1) ? 1 : -1;
  const dY = (Y & 1) ? 1 : -1;
  X = X >> 1;
  Y = Y >> 1;
  W = (W + 1) >> 1;
  const OFF = X + Y * W;
  const u0 = Uo[OFF], v0 = Vo[OFF];
  if (!params.fancy_upscaler) {
    return to_rgb(luma, u0, v0);
  }
  // compute the 'far' X/Y coordinates (Xf,Yf):
  const Xf = clamp(X + dX, 0, W - 1);
  const Yf = clamp(Y + dY, 0, H - 1);
  // get nearby samples
  const u1 = Uo[Xf + Y * W], u2 = Uo[X + Yf * W], u3 = Uo[Xf + Yf * W];
  const v1 = Vo[Xf + Y * W], v2 = Vo[X + Yf * W], v3 = Vo[Xf + Yf * W];
  // and apply the fancy upscaler:
  const u = filter_9331(u0, u1, u2, u3);
  const v = filter_9331(v0, v1, v2, v3);
  return to_rgb(luma, u, v);
}

function convert_to_rgb(Y, U, V, RGB, ERR) {
  let total_err = 0.
  for (let y = 0; y < RGB.height; ++y) {
    for (let x = 0; x < RGB.width; ++x) {
      const rgb = get_rgb(Y, U, V, x, y, RGB.width, RGB.height);
      const off = 4 * (x + y * params.W);
      RGB.data[off + 0] = rgb[0];
      RGB.data[off + 1] = rgb[1];
      RGB.data[off + 2] = rgb[2];
      RGB.data[off + 3] = 255;

      const err = get_err(x, y, rgb);
      total_err += err;
      ERR.data[off + 0] = err;
      ERR.data[off + 1] = err;
      ERR.data[off + 2] = err;
      ERR.data[off + 3] = 255;
    }
  }
  return total_err / (RGB.width * RGB.height);
}

function get_err(x, y, rgb) {
  const off = 4 * (x + y * params.W);
  const er = params.RGB.data[off + 0] - rgb[0];
  const eg = params.RGB.data[off + 1] - rgb[1];
  const eb = params.RGB.data[off + 2] - rgb[2];
  return er * er + eg * eg + eb * eb;
}

////////////////////////////////////////////////////////////////////////////////

function to_y(r, g, b) {
  return (+16839 * r + 33059 * g + 6420 * b + (16 << 16) + (1 << 15)) >> 16; // in [16, 235] range
}

function to_uv(r, g, b) {
  const U = ( -9719 * r - 19081 * g + 28800 * b + (128 << 16) + (1 << 16)) >> 16;
  const V = (+28800 * r - 24116 * g -  4684 * b + (128 << 16) + (1 << 16)) >> 16;
  return [U, V];  // in [16,240] range
}

function to_yuv(r, g, b) {
  const Y = to_y(r, g, b);
  const [U, V] = to_uv(r, g, b);
  return new Uint8ClampedArray([Y, U, V]);
}

function get_yuv(RGB, x, y, w, h) {
  const off = clamp_coord(x, y, w, h);
  return to_yuv(RGB[off + 0], RGB[off + 1], RGB[off + 2]);
}

function get_y(RGB, x, y, w, h) {
  const off = clamp_coord(x, y, w, h);
  return to_y(RGB[off + 0], RGB[off + 1], RGB[off + 2]);
}

function get_uv(RGB, x, y, w, h) {
  const off = clamp_coord(x, y, w, h);
  return to_uv(RGB[off + 0], RGB[off + 1], RGB[off + 2]);
}

function convert_to_yuv_fast(RGB, Yo, Uo, Vo, delta) {
  for (let y = 0; y < params.H; ++y) {
    for (let x = 0; x < params.W; ++x) {
      Yo[x + y * params.W] = get_y(RGB, x, y, params.W, params.H);
    }
  }

  const total = 4 * delta * delta;
  const round = (total + 1) >> 1
  for (let y = 0; y < params.h; ++y) {
    for (let x = 0; x < params.w; ++x) {
      let all_U = 0, all_V = 0;
      for (let Y = -delta; Y < delta; ++Y) {
        for (let X = -delta; X < delta; ++X) {
          const yuv = get_yuv(RGB, 2 * x + X, 2 * y + Y, params.W, params.H);
          all_U += yuv[1];
          all_V += yuv[2];
        }
      }
      all_U = Math.floor((all_U + round) / total);
      all_V = Math.floor((all_V + round) / total);
      const off = x + y * params.w;
      Uo[off] = all_U;
      Vo[off] = all_V;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

const GUI_change = async () => { await render(); }
const GUI_reload = async () => { await draw(); }

const GUI_init = () => {
  if (params.no_gui) {
    params.gui = undefined;
    return;
  }
  params.gui = new lil.GUI({container: document.querySelector("gui-container"), name: 'Sharp-YUV'});
  params.gui.add(params, 'iters', 1, 32, 1).name('iterations').listen().onChange(GUI_change);
  params.gui.add(params, 'zoom', 1, 100, 1).name('zoom level').listen().onChange(GUI_reload);
  params.gui.add(params, 'fancy_upscaler').name('fancy upscaler').listen().onChange(GUI_change);
  params.gui.add(params, 'gamma_aware').name('gamma-corrected').listen().onChange(GUI_change);
  params.gui.add(params, 'YUV_W', 64, 384, 16).name('zoom size').listen().onChange(GUI_change);

  params.gui.add(params, 'txt_info').name('info').listen().disable();

  params.gui.domElement.style.top = '5%';
  params.gui.domElement.style.right = '3%';
}

////////////////////////////////////////////////////////////////////////////////

function draw_text(ctx, text, x, y, line_width = 4) {
  if (text != undefined) {
    ctx.lineWidth = line_width;
    ctx.strokeStyle = '#fff';
    ctx.strokeText(text, x, y);
    ctx.fillStyle = '#000';
    ctx.fillText(text, x, y);
  }
}

function draw_to(dst_name, src_data, x, y, w, h, text, is_img = false) {
  const off_canvas = document.createElement('canvas');
  off_canvas.width = src_data.width;
  off_canvas.height = src_data.height;
  const off_ctx = off_canvas.getContext("2d");
  if (is_img) {
    off_ctx.drawImage(src_data, 0, 0);
  } else {
    off_ctx.putImageData(src_data, 0, 0);
  }

  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  dst_ctx.drawImage(off_canvas, x, y, w, h, 0, 0, dst.width, dst.height);
  draw_text(dst_ctx, text, 2, 20, 4);
}

function draw_yuv(dst_name, data, stride, xo, yo, w, h, Xo, Yo, Wo, Ho, text) {
  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  const y_dst = dst_ctx.getImageData(Xo, Yo, Wo, Ho);
  for (let y = 0; y < Ho; ++y) {
    const yy = Math.min(yo + Math.floor(y * h / Ho), params.H - 1);
    for (let x = 0; x < Wo; ++x) {
      const xx = Math.min(xo + Math.floor(x * w / Wo), params.W - 1);
      const v = data[xx + yy * stride];
      const off = (x + y * Wo) * 4;
      y_dst.data[off + 0] = v;
      y_dst.data[off + 1] = v;
      y_dst.data[off + 2] = v;
      y_dst.data[off + 3] = 255;
    }
  }
  dst_ctx.putImageData(y_dst, Xo, Yo);
  dst_ctx.strokeStyle = '#000';
  dst_ctx.lineWidth = 1;
  dst_ctx.strokeRect(Xo, Yo, Wo - 1, Ho - 1);
  draw_text(dst_ctx, text, Xo + 2, Yo + 20, 3);
}

function draw() {
  const canvas = document.querySelector("#main-canvas");
  const ctx = canvas.getContext("2d");
  ctx.putImageData(params.RGB, 0, 0)

  const [x, y, w, h] = params.get_box();
  ctx.strokeStyle = "#eee";
  ctx.lineWidth = 3;
  ctx.setLineDash([4]);
  ctx.strokeRect(x, y, w, h);
  ctx.setLineDash([]);

  const S = params.YUV_W;
  const s = (S + 1) >> 1;

  draw_to('ref-rgb', params.RGB, x, y, w, h, "source");

  draw_yuv('fast-yuv', params.Yf, params.W, x, y, w, h,  0, 0, S, S, "Y");
  draw_yuv('fast-yuv', params.Uf, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  0, S, s, s, "U");
  draw_yuv('fast-yuv', params.Vf, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  s, S, s, s, "V");
  draw_to('fast-err', params.ERRf, x, y, w, h, `PSNR: ${params.psnr_f} dB`);

  draw_yuv('sharp-yuv', params.Ys, params.W, x, y, w, h,  0, 0, S, S, "Y");
  draw_yuv('sharp-yuv', params.Us, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  0, S, s, s, "U");
  draw_yuv('sharp-yuv', params.Vs, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  s, S, s, s, "V");
  draw_to('sharp-err', params.ERRs, x, y, w, h, `PSNR: ${params.psnr_s} dB`);

  if (params.show_src) {
    draw_to('fast-rgb', params.RGB, x, y, w, h, "source");
    draw_to('sharp-rgb', params.RGB, x, y, w, h, "source");
  } else {
    draw_to('fast-rgb', params.RGBf, x, y, w, h, "fast");
    draw_to('sharp-rgb', params.RGBs, x, y, w, h, "sharp");
  }
  draw_arrows();
}

////////////////////////////////////////////////////////////////////////////////

function import_image(image) {
  let Wo = params.Main_W, Ho = params.Main_H;
  let W = image.width, H = image.height;
  console.log(`size in: ${W} x ${H} in canvas: ${Wo} x ${Ho}`);
  if (W > Wo || H > Ho) {   // needs resizing?
    if (W * Ho > Wo * H) {
      H = Math.floor(H * Wo / W);
      W = Wo;
    } else {
      W = Math.floor(W * Ho / H);
      H = Ho;
    }
  }
  console.log(`adjusting to size: ${W} x ${H}`);

  const canvas = document.querySelector("#main-canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // save the definitive RGB source for later
  draw_to('main-canvas', image, 0, 0, image.width, image.height, undefined, true);
  params.RGB = ctx.getImageData(0, 0, W, H);
  params.W = W;
  params.H = H;
  params.w = (W + 1) >>> 1;
  params.h = (H + 1) >>> 1;
  params.POI = { x: (W >> 1) & ~1, y: (H >> 1) & ~1, };
  params.zoom = 50;
  params.YUV_W = (params.YUV_W + 1) & ~1;  // make sure it's even

  render();
}

function set_image(src) {
  let image = new Image();
  image.onload = function() {
    import_image(image);
  };
  image.src = src;
}

function render() {
  compute_everything();
  draw();
}

////////////////////////////////////////////////////////////////////////////////
// Drag'n'Drop

function PreventDefaults (e) {
  e.preventDefault();
  e.stopPropagation();
}
function HandleDrop(e) {
  HandleFile(e.dataTransfer.files[0]);
}
function HandleFile(file) {
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onloadend = function() { set_image(reader.result); }
}

async function init_image() {
  const dropArea = document.getElementById('main-area');
  function highlight(e) { dropArea.classList.add('highlight'); }
  function unhighlight(e) { dropArea.classList.remove('highlight'); }

  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, PreventDefaults, false); }
  );
  ['dragenter', 'dragover'].forEach(
    name => { dropArea.addEventListener(name, highlight, false); }
  );
  ['dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, unhighlight, false); }
  );
  dropArea.addEventListener('drop', HandleDrop, false)

  window.addEventListener('resize', draw);
  window.addEventListener('scroll', draw);

  const canvas = document.getElementById('main-canvas');
  canvas.addEventListener('mousemove', (e) => {
    if (!e.buttons) return;
    params.set_POI(e.x, e.y);
    draw();
  });
  canvas.addEventListener('wheel', (e) => {
    if (Math.abs(e.wheelDelta) > 3) {
      params.zoom = clamp(params.zoom + (e.wheelDelta < 0 ? 1 : -1), 1, 100);
      draw();
    }
    e.preventDefault();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key == ' ') {
      params.show_src = true;
      draw();
    } else if (e.key == 'f') {
      params.fancy_upscaler = !params.fancy_upscaler;
      render();
    } else if (e.key == 'g') {
      params.gamma_aware = !params.gamma_aware;
      render();
    } else {
      console.log(`down: ${e.key}`);
      return;
    }
    e.preventDefault();
  });
  document.addEventListener('keyup', (e) => {
    if (e.key == ' ') {
      params.show_src = false;
      draw();
    } else {
      console.log(`up: ${e.key}`);
      return;
    }
    e.preventDefault();
  });

  set_image("./SF.webp");
}

////////////////////////////////////////////////////////////////////////////////

function draw_arrows() {
  const svg = get_adjusted_svg_container('arrow-svg');

  const src = get_element_rectangle('main-canvas');
  const [x, y, w, h] = params.get_box();
  const x0 = Math.floor(src.x + x + w/2);
  const y0 = Math.floor(src.y + y + h/2);

  const dst = get_element_rectangle('ref-rgb');
  const x1 = Math.floor(dst.x + dst.width);
  const y1 = Math.floor(dst.y + dst.height / 2);

  const yuv_dst = get_element_rectangle('fast-yuv');
  const x2 = Math.floor(dst.x + dst.width / 2);
  const y2 = Math.floor(dst.y + dst.height);
  const x3 = Math.floor(yuv_dst.x + yuv_dst.width / 2);
  const y3 = Math.floor(yuv_dst.y + 10);

  const options = {
    color: '#fffa',
    stroke: '#fffa',
    line_width: 14,
    head_length: 6,
    head_width: 6,
  }
  svg_draw_arrow(svg, 'line1', x0, y0, x1, y1, options);
  svg_draw_arrow(svg, 'line2', x2, y2, x3, y3, options);
}

////////////////////////////////////////////////////////////////////////////////

async function main() {
  try {
    await init_image();
    GUI_init();
  } catch(e) { console.log(`Error: ${e};`); }
}

</script>

</body>
</html>
