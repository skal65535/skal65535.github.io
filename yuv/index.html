<!--
Explanation page for Sharp-YUV algorithm.
skal/ (pascal.massimino@gmail.com) 2025
 -->
<!DOCTYPE html>
<html>

<head>
<title>Sharp-YUV: sharp conversion to YUV420</title>
<link rel="stylesheet" href="../splats/style.css">
<style>
.canvas {
  position: absolute;
  z-index:0;
  border: 2px solid #000; border-radius: 20px;
  margin: 0px;
  background: #000;
  box-shadow: 0 0 8px black;
  outline: 1px solid black;
}

#main-area.highlight { border-color: purple; }
.button {
  display: inline-block;
  padding: 4px;
  background: #bbc;
  cursor: pointer;
  border-radius: 5px;
  border: 2px solid #334;
  z-index:1;
  position:relative;
  font-size: 14px;
}
.button:hover {
  background: #cce;
}
#gui {
 position: relative;
 top: -230px;
 right: -6px;
}
#arrow-svg {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;  /* pass-through clicks */
  z-index: 10;  /* on top */
}
</style>
</head>

<body onload="main();">
<svg id='arrow-svg'></svg>
<div id="main-area">
  <div height='100px'>
    <h2><center>Illustration of the Sharp-YUV conversion technique</center></h2>
    <font size='-1'>
    Drag and drop image on the canvas below.
    Or <label class='button' for="FileElmt">select an image</label>.<br/>
    Mouse-click will move the zoom area. Mouse-Wheel will change the zoom level<br/>
    Canvas key: <code>f</code> to toggle fancy upscaler. <code>space</code>
    to show the source in reconstructed RGB.<br/>
    </font>
  </div>
  <hr>

  <form class="my-form">
    <input type="file" id="FileElmt" style='display:none;'
           multiple accept="image/*" onchange="HandleFile(this.files[0])">
  </form>

  <div id="gui-container">
    <canvas id="ref-rgb" style='position:relative; bottom:40px; left:20px; border: 2px solid #334;'></canvas>
    <canvas id="main-canvas" style=''></canvas>
    <br/>
    <table border='1px'>
      <tr>
        <th></th>
        <th>Y/U/V</th><th>reconstructed RGB</th><th>error map</th>
      </tr>
      <tr>
        <td style='writing-mode: sideways-rl;'>Regular</td>
        <td valign='top'><canvas id="fast-yuv" width='256px' height='384px'></canvas></td>
        <td valign='top'><canvas id="fast-rgb" width='256px' height='256px'></canvas></td>
        <td valign='top'><canvas id="fast-err" width='256px' height='256px'></canvas></td>
      </tr>
      <tr>
        <td style='writing-mode: sideways-rl;'>Sharp YUV</td>
        <td valign='top'><canvas id="sharp-yuv" width='256px' height='384px' style='left:-2px;'></canvas></td>
        <td valign='top'><canvas id="sharp-rgb" width='256px' height='256px' style='left:-2px;'></canvas></td>
        <td valign='top'><canvas id="sharp-err" width='256px' height='256px' style='left:-2px;'></canvas></td>
      </tr>
    </table>
  </div>
</div>
<form action="https://skal65535.github.io/" >
  <input type="submit" value="skal 2025" id="skal-back" style='position:relative; left:1%;'/>
</form>

<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
<script src="../common/args.js"></script>
<script src="../common/utils.js"></script>
<script src="./arrow.js"></script>
<script src="./yuv.js"></script>

<script>
"use strict";

const params = {
  // user-controlled params
  iters: parse_arg('iters', 6, 1, 10),
  zoom: parse_arg('zoom', 50, 1, 100),
  fancy_upscaler: !parse_arg_bool('no_fancy'),
  delta: parse_arg('delta', 1, 1, 8),
  gamma_aware: !parse_arg_bool('no_gamma'),
  YUV_W: parse_arg('size', 128, 64, 384),
  // max dimension for the input image (resized to fit)
  Wo: parse_arg('Wo', 512, 256, 1024),
  Ho: parse_arg('Ho', 512, 256, 1024),

  // internal rendering state
  POI: {x: 0, y: 0},
  show_src: false,

  RGB: undefined,  // reference input
  Yf: undefined,   // Y-fast internal
  Uf: undefined,   // U-fast internal
  Vf: undefined,   // V-fast internal
  Ys: undefined,   // Y-sharp internal
  Us: undefined,   // U-sharp internal
  Vs: undefined,   // V-sharp internal
  RGBf: undefined,   // RGB-fast output
  RGBs: undefined,   // RGB-sharp output
  ERRf: undefined,   // RGB-fast error
  ERRs: undefined,   // RGB-sharp error

  gui: null,
  txt_info: "info",
  dbg: { timing: false, },

  W: 0,
  H: 0,
  w: 0,
  h: 0,

  set_POI: (x, y) => {
    const canvas = document.querySelector("#main-canvas");
    const bounds = canvas.getBoundingClientRect();
    params.POI.x = Math.floor(x - bounds.left);
    params.POI.y = Math.floor(y - bounds.top);
  },
  get_box: () => {
    const S = Math.floor(Math.pow(2., params.zoom / 10.));
    const X = params.POI.x - S;
    const Y = params.POI.y - S;
    return [X, Y, 2 * S, 2 * S];  // TODO: make coords even?
  },
};

////////////////////////////////////////////////////////////////////////////////

function PSNR(err2) {
  const x = 10. * Math.log10(255 * 255 * 3. / err2);
  return (Math.round(x * 100.) / 100.).toFixed(2);
}

function set_yuv_size(name) {
  const S = params.YUV_W;
  const Suv = (S + 1) >> 1;
  const canvas = document.getElementById(name);
  canvas.width = S;
  canvas.height = S + Suv;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.font = "18px serif";
}

function set_size(name) {
  const canvas = document.getElementById(name);
  canvas.width = params.YUV_W;
  canvas.height = params.YUV_W;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.font = "17px serif";
}

function update_canvas_dimensions() {
  // make sure it's even
  params.YUV_W = (params.YUV_W + 1) & ~1;

  set_size('ref-rgb');

  set_yuv_size('fast-yuv');
  set_size('fast-rgb');
  set_size('fast-err');

  set_yuv_size('sharp-yuv');
  set_size('sharp-rgb');
  set_size('sharp-err');
}

function compute_everything(image) {
  const W = params.W, H = params.H;
  const w = params.w, h = params.h;

  params.Yf = new Uint8ClampedArray(W * H);
  params.Uf = new Uint8ClampedArray(w * h);
  params.Vf = new Uint8ClampedArray(w * h);
  convert_to_yuv_fast(params.RGB.data, params.Yf, params.Uf, params.Vf, params.delta);
  params.RGBf = new ImageData(W, H);
  params.ERRf = new ImageData(W, H);
  const err2_f = convert_to_rgb(params.Yf, params.Uf, params.Vf, params.RGBf, params.ERRf);
  params.psnr_f = PSNR(err2_f);

  params.Ys = new Uint8ClampedArray(W * H);
  params.Us = new Uint8ClampedArray(w * h);
  params.Vs = new Uint8ClampedArray(w * h);
  convert_to_yuv_fast(params.RGB.data, params.Ys, params.Us, params.Vs, 3);
  params.RGBs = new ImageData(W, H);
  params.ERRs = new ImageData(W, H);
  const err2_s = convert_to_rgb(params.Ys, params.Us, params.Vs, params.RGBs, params.ERRs);
  params.psnr_s = PSNR(err2_s);
}

////////////////////////////////////////////////////////////////////////////////

const GUI_change = async () => { await render(); }
const GUI_reload = async () => { await draw(); }

const GUI_init = () => {
  if (params.no_gui) {
    params.gui = undefined;
    return;
  }
  params.gui = new lil.GUI({container: document.querySelector("gui-container"), name: 'Sharp-YUV'});
  params.gui.add(params, 'iters', 1, 32, 1).name('iterations').listen().onChange(GUI_change);
  params.gui.add(params, 'zoom', 1, 100, 1).name('zoom level').listen().onChange(GUI_reload);
  params.gui.add(params, 'delta', 1, 8, 1).name('U/V averaging size').listen().onChange(GUI_change);
  params.gui.add(params, 'fancy_upscaler').name('fancy upscaler').listen().onChange(GUI_change);
  params.gui.add(params, 'gamma_aware').name('gamma-corrected').listen().onChange(GUI_change);
  params.gui.add(params, 'YUV_W', 64, 384, 16).name('zoom size').listen().onChange(
    () => { update_canvas_dimensions(); draw(); }
  );

  params.gui.add(params, 'txt_info').name('info').listen().disable();

  params.gui.domElement.style.top = '5%';
  params.gui.domElement.style.right = '3%';
}

////////////////////////////////////////////////////////////////////////////////

function draw_text(ctx, text, x, y, line_width = 4) {
  if (text != undefined) {
    ctx.lineWidth = line_width;
    ctx.strokeStyle = '#fff';
    ctx.strokeText(text, x, y);
    ctx.fillStyle = '#000';
    ctx.fillText(text, x, y);
  }
}

function draw_to(dst_name, src_data, x, y, w, h, text, is_img = false) {
  const off_canvas = document.createElement('canvas');
  off_canvas.width = src_data.width;
  off_canvas.height = src_data.height;
  const off_ctx = off_canvas.getContext("2d");
  if (is_img) {
    off_ctx.drawImage(src_data, 0, 0);
  } else {
    off_ctx.putImageData(src_data, 0, 0);
  }

  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  dst_ctx.clearRect(0, 0, dst.width, dst.height);
  dst_ctx.drawImage(off_canvas, x, y, w, h, 0, 0, dst.width, dst.height);
  draw_text(dst_ctx, text, 2, 20, 4);
}

function draw_yuv(dst_name, data, stride, xo, yo, w, h, Xo, Yo, Wo, Ho, text) {
  const dst = document.getElementById(dst_name);
  const dst_ctx = dst.getContext("2d");
  const y_dst = dst_ctx.getImageData(Xo, Yo, Wo, Ho);
  for (let y = 0; y < Ho; ++y) {
    const yy = Math.min(yo + Math.floor(y * h / Ho), params.H - 1);
    for (let x = 0; x < Wo; ++x) {
      const xx = Math.min(xo + Math.floor(x * w / Wo), params.W - 1);
      const v = data[xx + yy * stride];
      const off = (x + y * Wo) * 4;
      y_dst.data[off + 0] = v;
      y_dst.data[off + 1] = v;
      y_dst.data[off + 2] = v;
      y_dst.data[off + 3] = 255;
    }
  }
  dst_ctx.putImageData(y_dst, Xo, Yo);
  dst_ctx.strokeStyle = '#000';
  dst_ctx.lineWidth = 1;
  dst_ctx.strokeRect(Xo, Yo, Wo - 1, Ho - 1);
  draw_text(dst_ctx, text, Xo + 2, Yo + 20, 3);
}

function draw() {
  const canvas = document.querySelector("#main-canvas");
  const ctx = canvas.getContext("2d");
  ctx.putImageData(params.RGB, 0, 0)

  const [x, y, w, h] = params.get_box();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#000";
  ctx.strokeRect(x + 1, y + 1, w, h);
  ctx.strokeStyle = "#eee";
  ctx.setLineDash([4]);
  ctx.strokeRect(x, y, w, h);
  ctx.setLineDash([]);

  const S = params.YUV_W;
  const s = (S + 1) >> 1;

  draw_to('ref-rgb', params.RGB, x, y, w, h, "source");

  draw_yuv('fast-yuv', params.Yf, params.W, x, y, w, h,  0, 0, S, S, "Y");
  draw_yuv('fast-yuv', params.Uf, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  0, S, s, s, "U");
  draw_yuv('fast-yuv', params.Vf, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  s, S, s, s, "V");
  draw_to('fast-err', params.ERRf, x, y, w, h, `PSNR: ${params.psnr_f} dB`);

  draw_yuv('sharp-yuv', params.Ys, params.W, x, y, w, h,  0, 0, S, S, "Y");
  draw_yuv('sharp-yuv', params.Us, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  0, S, s, s, "U");
  draw_yuv('sharp-yuv', params.Vs, params.w, x >> 1, y >> 1, w >> 1, h >> 1,  s, S, s, s, "V");
  draw_to('sharp-err', params.ERRs, x, y, w, h, `PSNR: ${params.psnr_s} dB`);

  if (params.show_src) {
    draw_to('fast-rgb', params.RGB, x, y, w, h, "source");
    draw_to('sharp-rgb', params.RGB, x, y, w, h, "source");
  } else {
    draw_to('fast-rgb', params.RGBf, x, y, w, h, "fast");
    draw_to('sharp-rgb', params.RGBs, x, y, w, h, "sharp");
  }
  draw_arrows();
}

////////////////////////////////////////////////////////////////////////////////

function import_image(image) {
  let Wo = params.Wo, Ho = params.Ho;
  let W = image.width, H = image.height;
  console.log(`size in: ${W} x ${H} in max canvas: ${Wo} x ${Ho}`);
  if (W > Wo || H > Ho) {   // needs resizing?
    if (W * Ho > Wo * H) {
      H = Math.floor(H * Wo / W);
      W = Wo;
    } else {
      W = Math.floor(W * Ho / H);
      H = Ho;
    }
  }
  console.log(`adjusting to size: ${W} x ${H}`);

  const canvas = document.querySelector("#main-canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // save the definitive RGB source for later
  draw_to('main-canvas', image, 0, 0, image.width, image.height, undefined, true);
  params.RGB = ctx.getImageData(0, 0, W, H);
  params.W = W;
  params.H = H;
  params.w = (W + 1) >>> 1;
  params.h = (H + 1) >>> 1;
  params.POI = { x: (W >>> 1) & ~1, y: (H >>> 1) & ~1, };

  render();
}

function set_image(src) {
  let image = new Image();
  image.onload = function() {
    import_image(image);
  };
  image.src = src;
}

function render() {
  compute_everything();
  update_canvas_dimensions();
  draw();
}

////////////////////////////////////////////////////////////////////////////////
// Drag'n'Drop

function PreventDefaults (e) {
  e.preventDefault();
  e.stopPropagation();
}
function HandleDrop(e) {
  HandleFile(e.dataTransfer.files[0]);
}
function HandleFile(file) {
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onloadend = function() { set_image(reader.result); }
}

async function init_image() {
  const dropArea = document.getElementById('main-area');
  function highlight(e) { dropArea.classList.add('highlight'); }
  function unhighlight(e) { dropArea.classList.remove('highlight'); }

  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, PreventDefaults, false); }
  );
  ['dragenter', 'dragover'].forEach(
    name => { dropArea.addEventListener(name, highlight, false); }
  );
  ['dragleave', 'drop'].forEach(
    name => { dropArea.addEventListener(name, unhighlight, false); }
  );
  dropArea.addEventListener('drop', HandleDrop, false)

  window.addEventListener('resize', draw);
  window.addEventListener('scroll', draw);

  const canvas = document.getElementById('main-canvas');
  canvas.addEventListener('mousemove', (e) => {
    if (!e.buttons) return;
    params.set_POI(e.x, e.y);
    draw();
  });
  const container = document.getElementById('gui-container');
  container.addEventListener('wheel', (e) => {
    if (Math.abs(e.wheelDelta) > 3) {
      params.zoom = clamp(params.zoom + (e.wheelDelta < 0 ? 1 : -1), 1, 100);
      draw();
    }
    e.preventDefault();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key == ' ') {
      params.show_src = true;
      draw();
    } else if (e.key == 'f') {
      params.fancy_upscaler = !params.fancy_upscaler;
      render();
    } else if (e.key == 'g') {
      params.gamma_aware = !params.gamma_aware;
      render();
    } else {
      console.log(`down: ${e.key}`);
      return;
    }
    e.preventDefault();
  });
  document.addEventListener('keyup', (e) => {
    if (e.key == ' ') {
      params.show_src = false;
      draw();
    } else {
      console.log(`up: ${e.key}`);
      return;
    }
    e.preventDefault();
  });

//  set_image("./SF.webp");
  set_image("./test_yuv.png");
}

////////////////////////////////////////////////////////////////////////////////

function draw_arrows() {
  const svg = get_adjusted_svg_container('arrow-svg');

  const src = get_element_rectangle('main-canvas');
  const [x, y, w, h] = params.get_box();
  const x0 = Math.floor(src.x + x + w/2);
  const y0 = Math.floor(src.y + y + h/2);

  const dst = get_element_rectangle('ref-rgb');
  const x1 = Math.floor(dst.x + dst.width);
  const y1 = Math.floor(dst.y + dst.height / 2);

  const yuv_dst = get_element_rectangle('fast-yuv');
  const x2 = Math.floor(dst.x + dst.width / 2);
  const y2 = Math.floor(dst.y + dst.height);
  const x3 = Math.floor(yuv_dst.x + yuv_dst.width / 2);
  const y3 = Math.floor(yuv_dst.y + 10);

  const options = {
    color: '#fffa',
    stroke: '#fffa',
    line_width: 14,
    head_length: 6,
    head_width: 6,
  }
  svg_draw_arrow(svg, 'line1', x0, y0, x1, y1, options);
  svg_draw_arrow(svg, 'line2', x2, y2, x3, y3, options);
}

////////////////////////////////////////////////////////////////////////////////

async function main() {
  try {
    await init_image();
    GUI_init();
  } catch(e) { console.log(`Error: ${e};`); }
}

</script>

</body>
</html>
